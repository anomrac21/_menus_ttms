<script>
// Simple location selection using dropdown
let number = '{{ site.Params.orderingsystem.whatsapp }}'; // Fallback number
const name = '{{ site.Params.title }}'
const hastables = {{ default false site.Params.orderingsystem.hastables }};

// Location storage key
const LOCATION_STORAGE_KEY = 'ttms_selected_location';

// Menu items cache
let menuItemsCache = null;
let menuItemsCachePromise = null;

// Track selections per category
let categorySidesTracking = {};

// Function to fetch menu items JSON
async function fetchMenuItems() {
	if (menuItemsCache) {
		console.log('üì¶ Using cached menu items');
		return menuItemsCache;
	}
	
	if (menuItemsCachePromise) {
		console.log('‚è≥ Waiting for existing fetch to complete');
		return menuItemsCachePromise;
	}
	
	console.log('üîÑ Fetching menu items from JSON API...');
	menuItemsCachePromise = fetch('/api/menu-items.json')
		.then(response => {
			if (!response.ok) {
				throw new Error(`HTTP error! status: ${response.status}`);
			}
			return response.json();
		})
		.then(data => {
			console.log('‚úÖ Menu items loaded:', data.total_count, 'items');
			menuItemsCache = data.menu_items;
			menuItemsCachePromise = null;
			return menuItemsCache;
		})
		.catch(error => {
			console.error('‚ùå Error fetching menu items:', error);
			menuItemsCachePromise = null;
			return null;
		});
	
	return menuItemsCachePromise;
}

// Function to find menu item by URL
function findMenuItemByUrl(url) {
	if (!menuItemsCache) {
		console.error('‚ùå Menu items not loaded yet');
		return null;
	}
	
	const item = menuItemsCache.find(item => item.url === url);
	if (!item) {
		console.error('‚ùå Menu item not found for URL:', url);
	}
	return item;
}

// Function to find menu item by ID
function findMenuItemById(id) {
	if (!menuItemsCache) {
		console.error('‚ùå Menu items not loaded yet');
		return null;
	}
	
	const item = menuItemsCache.find(item => item.id === id);
	if (!item) {
		console.error('‚ùå Menu item not found for ID:', id);
	}
	return item;
}

// Function to handle location selection from dropdown
function selectLocation(whatsappNumber) {
	if (whatsappNumber && whatsappNumber.trim() !== '') {
		const oldNumber = number;
		number = whatsappNumber;
		console.log('üìç Location selected - WhatsApp number changed from', oldNumber, 'to:', number);
		
		// Save selected location to localStorage
		saveSelectedLocation(whatsappNumber);
		
		// Update cart location display
		updateCartLocationDisplay();
	} else {
		console.log('üìç No location selected');
		number = '{{ site.Params.orderingsystem.whatsapp }}'; // Reset to fallback
		
		// Clear saved location from localStorage
		clearSelectedLocation();
	}
}

// Function to update cart location display
function updateCartLocationDisplay() {
	const locationSelect = document.getElementById('locationSelect');
	if (locationSelect && locationSelect.value) {
		const selectedOption = locationSelect.options[locationSelect.selectedIndex];
		const address = selectedOption.getAttribute('data-address');
		if (address) {
			console.log('üõí Cart location updated to:', address);
		}
	}
}

// Function to get current location data for table modal
function getCurrentLocationData() {
	const locationSelect = document.getElementById('locationSelect');
	if (locationSelect && locationSelect.value) {
		const selectedOption = locationSelect.options[locationSelect.selectedIndex];
		const address = selectedOption.getAttribute('data-address');
		const whatsapp = selectedOption.value;
		const lat = selectedOption.getAttribute('data-lat');
		const lng = selectedOption.getAttribute('data-lng');
		const orderingtables = selectedOption.getAttribute('data-orderingtables');
		
		if (address && whatsapp) {
			let parsedOrderingTables = [];
			if (orderingtables && orderingtables.trim() !== '') {
				parsedOrderingTables = orderingtables.split(',').map(table => table.trim());
			}
			
			return {
				address: address,
				whatsapp: whatsapp,
				lat: lat,
				lng: lng,
				orderingtables: parsedOrderingTables
			};
		}
	}
	return null;
}

// Function to save selected location to localStorage
function saveSelectedLocation(whatsappNumber) {
	try {
		localStorage.setItem(LOCATION_STORAGE_KEY, whatsappNumber);
		console.log('üíæ Location saved to localStorage:', whatsappNumber);
	} catch (error) {
		console.error('‚ùå Error saving location to localStorage:', error);
	}
}

// Function to load selected location from localStorage
function loadSelectedLocation() {
	try {
		const savedLocation = localStorage.getItem(LOCATION_STORAGE_KEY);
		if (savedLocation && savedLocation.trim() !== '') {
			console.log('üíæ Loading saved location from localStorage:', savedLocation);
			return savedLocation;
		}
	} catch (error) {
		console.error('‚ùå Error loading location from localStorage:', error);
	}
	return null;
}

// Function to clear selected location from localStorage
function clearSelectedLocation() {
	try {
		localStorage.removeItem(LOCATION_STORAGE_KEY);
		console.log('üóëÔ∏è Location cleared from localStorage');
	} catch (error) {
		console.error('‚ùå Error clearing location from localStorage:', error);
	}
}

// Function to set location dropdown to saved value
function setLocationDropdown(savedLocation) {
	const locationSelect = document.getElementById('locationSelect');
	if (locationSelect && savedLocation) {
		// Find the option with the saved WhatsApp number
		for (let i = 0; i < locationSelect.options.length; i++) {
			if (locationSelect.options[i].value === savedLocation) {
				locationSelect.selectedIndex = i;
				console.log('üìç Location dropdown set to saved location:', savedLocation);
				return true;
			}
		}
	}
	return false;
}

const messageStart = 'Powered by TTMenus\n'+name+'\nHello, Good Day\nI would like to order the following\n\nORDER\n';
let messageBody = '';
const messageEnd = '\nThank You!\nLooking forward to confirming this order';

let modes =  [ 	{'name':'takeaway'},{'name':'dinein'}];
let currentMode = 'dinein'; 

let orderSize = '';
let orderFlav = '';

let order = [];
let basePrice = 0;

let orderSides = [];
let sidePrice = 0;
let regAmt=0;
let premAmt=0;

let orderAdd = [];
let addPrice = 0;

let orderMod = [];
let modPrice = 0;

let vat = {{ site.Params.orderingsystem.vat }};
let vatcost = 0;

let service = {{ site.Params.orderingsystem.servicecharge }};
let servicecost = 0;

let price = 0;

let myTable='';

let currentoptions;

let sizePrice=0;

function showShop(){
	document.getElementById("orderModal").classList.remove('order-hidden');
	document.body.classList.add('modal-open');
}
function closeShop(){
	document.getElementById("orderModal").classList.add('order-hidden');
	var cart = document.getElementById("cart");
  var footerBtns = document.getElementById("footerBtns");
  cart.classList.add('cart-hidden');
  footerBtns.classList.add('grad2');
  footerBtns.classList.remove('grad1');
  footerBtns.classList.remove('bigfont');
  footerBtns.classList.add('smallfont');
	var addbtn = document.getElementById("sidesButtonText");
	var modbtn = document.getElementById("modicon");
	orderSides=[];
  orderAdd=[];
	orderMod=[];
	regAmt=0;
	premAmt=0;
	//console.log(orderMod);
}
// Updated openItem function - supports both inline data and dynamic fetching
async function openItem(ele, options) {
	addFocus(ele);
	
	// Check if options is a string (URL or ID) - then fetch data
	if (typeof options === 'string') {
		console.log("üîÑ Loading item dynamically:", options);
		
		// Ensure menu items are loaded
		await fetchMenuItems();
		
		// Try to find by URL first, then by ID
		let itemData = findMenuItemByUrl(options);
		if (!itemData) {
			itemData = findMenuItemById(options);
		}
		
		if (!itemData) {
			console.error('‚ùå Could not find item:', options);
			alert('Sorry, this item could not be loaded. Please try again.');
			return;
		}
		
		// Convert JSON data to the format expected by the rest of the code
		options = {
			category: itemData.category,
			categoryurl: itemData.categoryUrl,
			name: itemData.linkTitle || itemData.name,
			url: itemData.url,
			images: itemData.images || [],
			desc: itemData.summary || '',
			sizes: itemData.sizes || [],
			flavours: itemData.flavours || [],
			items: itemData.prices || [],
			side_categories: itemData.side_categories || [],
			sides: itemData.sides || [],
			sideoptions: itemData.sideconfig || [],
			additions: itemData.additions || [],
			modifications: itemData.modifications || [],
			tags: itemData.tags || [],
			ingredients: itemData.ingredients || [],
			cookingmethods: itemData.cookingmethods || [],
			types: itemData.types || [],
			events: itemData.events || []
		};
		
		console.log("‚úÖ Item data loaded:", options.name);
	}
	
	console.log("openShop");
	showShop();
	regAmt=0;
	premAmt=0;
	sidePrice=0;
	addPrice=0;
	modPrice=0;
	currentoptions=options;
	document.getElementById("itemAmt").innerText=(1);
	document.getElementById("sideList").innerText='';
	document.getElementById("modList").innerText='';
	document.getElementById("addModList").innerText='';
	
	// Clear side categories containers and tracking
	document.getElementById("sideCategoriesButtonsContainer").innerHTML = '';
	document.getElementById("itemSideControl").innerHTML = '';
	categorySidesTracking = {}; // Reset category tracking

	document.getElementById("itemCategory").innerText=(options.category);
	const currentPageName = document.title;
	if (!currentPageName.startsWith(options.category)) { 
		document.getElementById("itemCategory").setAttribute('href',options.categoryurl); 
		document.getElementById("itemImages").setAttribute('href',options.url);
	}else{
		document.getElementById("itemCategory").setAttribute('href','#'); 
		document.getElementById("itemImages").setAttribute('href','#');
	}

	document.getElementById("sidesButtonText").innerText = "{{ site.Params.orderingmenu.sidesname | default "Sides" }}";
	
	document.getElementById("itemName").innerText=(options.name);
	if (!currentPageName.startsWith(options.name)) { 
		document.getElementById("itemName").setAttribute('href',options.url); 
		document.getElementById("itemImages").setAttribute('href',options.url);
	}else{
		document.getElementById("itemName").setAttribute('href','#'); 
		document.getElementById("itemImages").setAttribute('href','#');
	}
	document.getElementById("itemDesc").innerHTML=(options.desc);
	
	// Display taxonomy tags if available
	displayTaxonomyTags(options);

	if(options.images && options.images.length>0){
		var imgHtml = '';
		for (var i = 0; i<=options.images.length - 1;  i++) {
			imgHtml = imgHtml+'<img src="/'+options.images[i]+'">';
		}
		document.getElementById("itemImages").innerHTML=imgHtml;

	}else{
		document.getElementById("itemImages").innerHTML='<img src="/branding/favicon-400x200.webp">';
	}
	
	//Size Options
	var sizeHtml = '';
	for (var i = 0; i<=options.sizes.length - 1;  i++) {
				if(i==0){
			if(options.sizes[i]=='-'){
				sizeHtml = sizeHtml+'<a onclick="'+'setBaseSize(this);"'+' class="btn-size-option hide select">'+options.sizes[i]+'</a>';
			}else{
				sizeHtml = sizeHtml+'<a onclick="'+'setBaseSize(this);"'+' class="btn-size-option select">'+options.sizes[i]+'</a>';
			}
		}else{
			sizeHtml = sizeHtml+'<a onclick="'+'setBaseSize(this);"'+' class="btn-size-option">'+options.sizes[i]+'</a>';
		}
	}
	document.getElementById("itemSizeControl").innerHTML=sizeHtml;
	setBaseSize(document.getElementById("itemSizeControl").childNodes[0]);

//Flavours Options
	var flavoursHtml = '';
	for (var i = 0; i<=options.flavours.length - 1;  i++) {
				if(i==0){
			if(options.flavours[i]=='-'){
				flavoursHtml = flavoursHtml+'<a onclick=" setBaseFlav(this);'+'" class="btn-flavour-option hide select">'+options.flavours[i]+'</a>';
			}else{
				flavoursHtml = flavoursHtml+'<a onclick=" setBaseFlav(this);'+'" class="btn-flavour-option select">'+options.flavours[i]+'</a>';
			}
		}else{
			flavoursHtml = flavoursHtml+'<a onclick=" setBaseFlav(this);'+'" class="btn-flavour-option">'+options.flavours[i]+'</a>';
		}
	}
	document.getElementById("itemFlavourControl").innerHTML=flavoursHtml;
	setBaseFlav(document.getElementById("itemFlavourControl").childNodes[0]);

	//Sides Options - Handle both new side_categories and old sides structure
	var sideHtml = '';
	
	// Check for new side_categories structure first
	if(options.side_categories && options.side_categories.length > 0){
		// Hide legacy sides container
		document.getElementById("itemSideContainer").classList.add("hide");
		
		// Render individual buttons and overlays for each category
		renderSideCategoryButtons(options.side_categories);
		
		console.log(`‚úÖ ${options.side_categories.length} side categories configured`);
	} 
	// Fall back to old sides structure for backward compatibility
	else if(options.sides && options.sides.length>0){
		// Clear any dynamic buttons
		document.getElementById("sideCategoriesButtonsContainer").innerHTML = '';
		
		// Show legacy button container
		document.getElementById("itemSideContainer").classList.remove("hide");
		
		// Ensure button uses old function
		const sideButton = document.getElementById("reg");
		if (sideButton) sideButton.setAttribute("onclick", "openSideMenu();");
		
		// Create legacy overlay structure inside itemSideControl
		makeSidesHtml(sideHtml,0);
	} else {
		// No sides at all - hide and clear everything
		document.getElementById("itemSideContainer").classList.add("hide");
		document.getElementById("sideCategoriesButtonsContainer").innerHTML = '';
		document.getElementById("itemSideControl").innerHTML = '';
	}
	
	//Additional Options
	var additionsHtml = '';
	if(options.additions && options.additions.length>0){
		makeAdditionsHtml(additionsHtml,0);
	} else {
		document.getElementById("itemAddContainer").classList.add("hide");
	}
	
	//Mods Options
	var modificationsHtml = '';
	if(options.modifications && options.modifications.length>0){
		makeModificationsHtml(modificationsHtml,0);
	} else {
		document.getElementById("itemModContainer").classList.add("hide");
	}
	
	orderSides=[];
	orderAdd=[];
	orderMod=[];
	updatePrices();
}

// New function to render individual buttons and overlays for each category
function renderSideCategoryButtons(sideCategories) {
	console.log('üîß Creating separate buttons for', sideCategories.length, 'categories');
	
	const buttonsContainer = document.getElementById("sideCategoriesButtonsContainer");
	const overlaysContainer = document.getElementById("itemSideControl");
	
	if (!buttonsContainer || !overlaysContainer) {
		console.error('‚ùå Category containers not found');
		return;
	}
	
	// Clear previous buttons and overlays
	buttonsContainer.innerHTML = '';
	overlaysContainer.innerHTML = '';
	
	// Create a button and overlay for each category
	sideCategories.forEach((category, categoryIndex) => {
		const categoryName = category.category_name || `category_${categoryIndex}`;
		const displayName = category.display_name || 'Choose Options';
		const rawItems = category.items || [];
		const configArray = category.config || [];
		
		// Convert config array to object
		const config = {
			all_max: configArray[0] || 0,
			all_valuecount: configArray[1] || 0,
			all_value: configArray[2] || 0,
			regular_max: configArray[3] || 0,
			regular_valuecount: configArray[4] || 0,
			regular_value: configArray[5] || 0,
			premium_max: configArray[6] || 0,
			premium_valuecount: configArray[7] || 0,
			premium_value: configArray[8] || 0
		};
		
		// Store config globally
		if (!window.sideCategoryConfigs) window.sideCategoryConfigs = {};
		window.sideCategoryConfigs[categoryName] = config;
		
		// Create button HTML
		const buttonHtml = `
			<div id="itemSideContainer_${categoryName}" class="">
				<a id="reg_${categoryName}" class="btn-section-header" onclick="openSingleCategoryMenu('${categoryName}');">
					<i class="fa fa-plus"></i> <span>${displayName}</span>
				</a>
				<div id="sideList_${categoryName}" class=""></div>
			</div>
		`;
		buttonsContainer.innerHTML += buttonHtml;
		
		// Build items HTML for this category
		let itemsHtml = '';
		console.log(`üì¶ Category "${categoryName}" has ${rawItems.length / 3} items`);
		
		for (let i = 0; i < rawItems.length; i += 3) {
			const name = rawItems[i];
			const type = rawItems[i + 1];
			const price = rawItems[i + 2];
			
			const cssClass = type === 'Premium' ? 'premiumside' : 'regularside';
			const starIcon = type === 'Premium' ? ' <i class="fa fa-star"></i>' : '';
			
			itemsHtml += `<div class="side-item-container"><b class="hide">1</b><a class="btn-side-option ${cssClass}" data-category="${categoryName}" data-item-name="${name}" data-item-type="${type}" data-item-price="${price}" onclick="selectSideItem(this, '${categoryName}');">${name}${starIcon}</a><p class="btn-add-extra hide" onclick="addExtraSide(this, '${categoryName}');"><i class="fa fa-plus"></i></p></div>`;
		}
		
		// Create overlay HTML for this category (match old itemSideControl structure exactly)
		const overlayId = `itemSideControl_${categoryName}`;
		
		// Create a div element instead of using innerHTML to preserve event handlers
		const overlayDiv = document.createElement('div');
		overlayDiv.id = overlayId;
		overlayDiv.className = 'hide fadein';
		
		const containerDiv = document.createElement('div');
		containerDiv.className = 'container';
		
		const sidesDiv = document.createElement('div');
		sidesDiv.id = `itemSides_${categoryName}`;
		sidesDiv.innerHTML = `
			<h3 class="title center main-text-color">${displayName}</h3>
			<div class="side-items-scrollable">${itemsHtml}</div>
			<button class="btn-close-menu" onclick="closeSingleCategoryMenu('${categoryName}');">Confirm</button>
		`;
		
		containerDiv.appendChild(sidesDiv);
		overlayDiv.appendChild(containerDiv);
		overlaysContainer.appendChild(overlayDiv);
		
		console.log(`‚úÖ Created button and overlay for category: ${categoryName}`);
	});
	
	console.log('‚úÖ All category buttons and overlays created');
}

// Function to open a single category menu
function openSingleCategoryMenu(categoryName) {
	const parentContainer = document.getElementById('itemSideControl');
	const overlay = document.getElementById(`itemSideControl_${categoryName}`);
	
	if (overlay) {
		// Show parent container first
		if (parentContainer) {
			parentContainer.classList.remove('hide');
		}
		
		// Then show this specific overlay
		overlay.classList.remove('hide');
		console.log(`üé® Opened category menu: ${categoryName}`);
	} else {
		console.error(`‚ùå Overlay not found for category: ${categoryName}`);
	}
}

// Function to close a single category menu
function closeSingleCategoryMenu(categoryName) {
	const parentContainer = document.getElementById('itemSideControl');
	const overlay = document.getElementById(`itemSideControl_${categoryName}`);
	const summaryList = document.getElementById(`sideList_${categoryName}`);
	
	if (overlay) {
		// Hide this specific overlay
		overlay.classList.add('hide');
		
		// Update summary text for this category using category tracking
		if (summaryList) {
			const categoryItems = categorySidesTracking[categoryName] || [];
			summaryList.innerText = printArray(categoryItems);
			console.log(`üìù Summary for ${categoryName}:`, categoryItems);
		}
		
		// Check if all overlays are now hidden - if so, hide parent container
		if (parentContainer) {
			const allOverlays = parentContainer.querySelectorAll('[id^="itemSideControl_"]');
			const allHidden = Array.from(allOverlays).every(o => o.classList.contains('hide'));
			
			if (allHidden) {
				parentContainer.classList.add('hide');
			}
		}
		
		console.log(`‚úÖ Closed category menu: ${categoryName}`);
	} else {
		console.error(`‚ùå Overlay not found for category: ${categoryName}`);
	}
}

// Old function kept for reference - now replaced with individual category approach
function renderSideCategories(sideCategories) {
	console.log('üîß Rendering side categories:', sideCategories);
	console.log(`üìä Total categories to render: ${sideCategories.length}`);
	
	const container = document.getElementById("itemSideContainer");
	const sidesDiv = document.getElementById("itemSides");
	
	// Build HTML for all categories
	let categoriesHtml = '';
	
	sideCategories.forEach((category, categoryIndex) => {
		console.log(`\nüì¶ Processing category ${categoryIndex + 1}/${sideCategories.length}:`, category.category_name);
		const categoryName = category.category_name || `category_${categoryIndex}`;
		const displayName = category.display_name || 'Choose Options';
		const rawItems = category.items || [];
		const configArray = category.config || [];
		
		// Convert config array to object for easier access
		const config = {
			all_max: configArray[0] || 0,
			all_valuecount: configArray[1] || 0,
			all_value: configArray[2] || 0,
			regular_max: configArray[3] || 0,
			regular_valuecount: configArray[4] || 0,
			regular_value: configArray[5] || 0,
			premium_max: configArray[6] || 0,
			premium_valuecount: configArray[7] || 0,
			premium_value: configArray[8] || 0
		};
		
		// Store category config globally (we'll need it for validation)
		if (!window.sideCategoryConfigs) window.sideCategoryConfigs = {};
		window.sideCategoryConfigs[categoryName] = config;
		
		console.log(`üìã Category: ${categoryName}, Items: ${rawItems.length / 3}, Max: ${config.all_max}`);
		
		// Build items HTML for this category
		// Items come as flat array [name, type, price, name, type, price, ...]
		let itemsHtml = '';
		console.log(`üì¶ Raw items array for ${categoryName}:`, rawItems);
		console.log(`üì¶ Total items to process: ${rawItems.length / 3}`);
		
		for (let i = 0; i < rawItems.length; i += 3) {
			const name = rawItems[i];
			const type = rawItems[i + 1];
			const price = rawItems[i + 2];
			
			console.log(`  Item ${i/3 + 1}: ${name} (${type}) - $${price}`);
			
			const cssClass = type === 'Premium' ? 'premiumside' : 'regularside';
			const starIcon = type === 'Premium' ? ' <i class="fa fa-star"></i>' : '';
			
			// Wrap each item in a container div for proper element selection
			itemsHtml += `<div class="side-item-container"><b class="hide">1</b><a class="btn-side-option ${cssClass}" data-category="${categoryName}" data-item-name="${name}" data-item-type="${type}" data-item-price="${price}" onclick="selectSideItem(this, '${categoryName}');">${name}${starIcon}</a><p class="btn-add-extra hide" onclick="addExtraSide(this, '${categoryName}');"><i class="fa fa-plus"></i></p></div>`;
		}
		
		console.log(`üì¶ Generated HTML length: ${itemsHtml.length} characters`);
		
		// Build category section (match old structure for CSS compatibility)
		categoriesHtml += `
			<div class="side-category" data-category="${categoryName}">
				<h3 class="title center main-text-color">${displayName}</h3>
				<div class="side-items-scrollable">${itemsHtml}</div>
			</div>
		`;
	});
	
	// Add close button
	categoriesHtml += '<button class="btn-close-menu" onclick="closeSideCategoriesMenu();">Confirm</button>';
	
	console.log('üìù Final HTML to insert (first 500 chars):', categoriesHtml.substring(0, 500));
	console.log('üìù Total HTML length:', categoriesHtml.length);
	
	// Update the DOM
	sidesDiv.innerHTML = categoriesHtml;
	
	// Verify insertion
	const insertedContainers = sidesDiv.querySelectorAll('.side-item-container');
	const insertedCategories = sidesDiv.querySelectorAll('.side-category');
	console.log('üîç After insertion, found', insertedCategories.length, 'category sections in DOM');
	console.log('üîç After insertion, found', insertedContainers.length, 'item containers in DOM');
	
	// Log each category that was inserted
	insertedCategories.forEach((cat, idx) => {
		const catName = cat.getAttribute('data-category');
		const items = cat.querySelectorAll('.btn-side-option');
		console.log(`  Category ${idx + 1}: "${catName}" with ${items.length} items`);
	});
	
	container.classList.remove("hide");
	
	console.log('‚úÖ Side categories rendered');
}

// Function to select a side item from a category
function selectSideItem(element, categoryName) {
	console.log(`üñ±Ô∏è Click detected on item:`, element.dataset.itemName, `in category:`, categoryName);
	
	try {
		const config = window.sideCategoryConfigs[categoryName];
		if (!config) {
			console.error(`‚ùå No config found for category: ${categoryName}`);
			console.log('Available configs:', window.sideCategoryConfigs);
			return;
		}
		
		const type = element.dataset.itemType;
		const isSelected = element.classList.contains('select');
		
		console.log(`   Is selected: ${isSelected}, Type: ${type}`);
		
		if (isSelected) {
			// Deselect
			console.log('   ‚Üí Deselecting...');
			removeSideItem(element, categoryName);
		} else {
			// Check if we can add more - COUNT TOTAL QUANTITY, not just number of items
			console.log('   ‚Üí Selecting...');
			
			// Find the overlay container for this category
			const overlayId = `itemSideControl_${categoryName}`;
			const overlay = document.getElementById(overlayId);
			if (!overlay) {
				console.error(`‚ùå Overlay not found: ${overlayId}`);
				return;
			}
			
			const selectedItems = overlay.querySelectorAll('.btn-side-option.select');
			const maxItems = config.all_max || 99;
			
			console.log(`   Current selected items: ${selectedItems.length}, Max: ${maxItems}`);
		
		// Calculate total quantity across all selected items
		let totalQuantity = 0;
		selectedItems.forEach(item => {
			const itemParent = item.parentElement;
			const qtyDisplay = itemParent.querySelector('b');
			totalQuantity += qtyDisplay ? parseInt(qtyDisplay.innerText) || 1 : 1;
		});
		
		console.log(`üìä Current total quantity: ${totalQuantity}, Max allowed: ${maxItems}`);
		
		// Check if adding this item (qty 1) would exceed max
		if (totalQuantity < maxItems) {
			element.classList.add('select');
			addSideItem(element, categoryName);
			
			// Find quantity display and extra button (proper siblings)
			const parent = element.parentElement;
			const quantityDisplay = parent.querySelector('b');
			const extraButton = parent.querySelector('.btn-add-extra');
			
			if (quantityDisplay) quantityDisplay.classList.remove('hide');
			if (extraButton) extraButton.classList.remove('hide');
		} else {
			console.log(`‚ö†Ô∏è Maximum ${maxItems} items allowed for ${categoryName}. Currently at ${totalQuantity}.`);
			alert(`You can only select ${maxItems} item(s) total.`);
		}
	}
	} catch (error) {
		console.error('‚ùå Error in selectSideItem:', error);
		console.error('Stack trace:', error.stack);
	}
}

// Function to add a side item to the order
function addSideItem(element, categoryName) {
	try {
		console.log(`  üìù addSideItem called for:`, element.dataset.itemName);
		
		const name = element.dataset.itemName;
		const type = element.dataset.itemType;
		const price = parseFloat(element.dataset.itemPrice) || 0;
	
	// Get quantity from parent's <b> element
	const parent = element.parentElement;
	const quantityDisplay = parent.querySelector('b');
	const quantity = quantityDisplay ? parseInt(quantityDisplay.innerText) || 1 : 1;
	
	// Add to order with quantity prefix
	const orderItemName = `${quantity} ${name}`;
	orderSides.push(orderItemName);
	
	// Track this item for this category
	if (!categorySidesTracking[categoryName]) {
		categorySidesTracking[categoryName] = [];
	}
	categorySidesTracking[categoryName].push(orderItemName);
	
	// Update pricing based on config (match old addSides logic exactly)
	const config = window.sideCategoryConfigs[categoryName];
	
	if (type === 'Regular') {
		regAmt = regAmt + quantity;
		// Use >= to match old logic: if(regAmt>=currentoptions.sideoptions[4])
		if (config && regAmt >= (config.regular_valuecount || 0)) {
			sidePrice = sidePrice + (config.regular_value || price);
		}
	} else if (type === 'Premium') {
		premAmt = premAmt + quantity;
		// Use >= to match old logic: if(premAmt>=currentoptions.sideoptions[7])
		if (config && premAmt >= (config.premium_valuecount || 0)) {
			sidePrice = sidePrice + (config.premium_value || price);
		}
	}
	
	console.log(`‚ûï Added: ${orderItemName} (${type}), regAmt: ${regAmt}, premAmt: ${premAmt}, sidePrice: $${sidePrice}`);
	updatePrices();
	} catch (error) {
		console.error('‚ùå Error in addSideItem:', error);
		console.error('Stack trace:', error.stack);
	}
}

// Function to remove a side item from the order
function removeSideItem(element, categoryName) {
	try {
		console.log(`  üóëÔ∏è removeSideItem called for:`, element.dataset.itemName);
	const name = element.dataset.itemName;
	const type = element.dataset.itemType;
	const config = window.sideCategoryConfigs[categoryName];
	
	// Get quantity from parent's <b> element
	const parent = element.parentElement;
	const quantityDisplay = parent.querySelector('b');
	const quantity = quantityDisplay ? parseInt(quantityDisplay.innerText) || 1 : 1;
	
	// Remove from order
	const orderItemName = `${quantity} ${name}`;
	const index = orderSides.indexOf(orderItemName);
	if (index > -1) {
		orderSides.splice(index, 1);
	}
	
	// Remove from category tracking
	if (categorySidesTracking[categoryName]) {
		const catIndex = categorySidesTracking[categoryName].indexOf(orderItemName);
		if (catIndex > -1) {
			categorySidesTracking[categoryName].splice(catIndex, 1);
		}
	}
	
	// Update pricing (match old removeSides logic exactly)
	if (type === 'Regular') {
		// Use >= to match old logic: if(regAmt>=currentoptions.sideoptions[4])
		if (config && regAmt >= (config.regular_valuecount || 0)) {
			sidePrice = sidePrice - (config.regular_value || 0);
		}
		regAmt = regAmt - quantity;
	} else if (type === 'Premium') {
		// Use >= to match old logic: if(premAmt>=currentoptions.sideoptions[7])
		if (config && premAmt >= (config.premium_valuecount || 0)) {
			sidePrice = sidePrice - (config.premium_value || 0);
		}
		premAmt = premAmt - quantity;
	}
	
	// Update UI
	element.classList.remove('select');
	
	// Find and hide quantity and extra button
	const extraButton = parent.querySelector('.btn-add-extra');
	if (quantityDisplay) {
		quantityDisplay.classList.add('hide');
		quantityDisplay.innerText = 1;
	}
	if (extraButton) {
		extraButton.classList.add('hide');
	}
	
	console.log(`‚ûñ Removed: ${orderItemName} from order, regAmt: ${regAmt}, premAmt: ${premAmt}, sidePrice: $${sidePrice}`);
	updatePrices();
	} catch (error) {
		console.error('‚ùå Error in removeSideItem:', error);
		console.error('Stack trace:', error.stack);
	}
}

// Function to add extra quantity to a side item
function addExtraSide(element, categoryName) {
	console.log(`‚ûï addExtraSide called for category: ${categoryName}`);
	
	const parent = element.parentElement;
	const sideButton = parent.querySelector('.btn-side-option');
	const quantityDisplay = parent.querySelector('b');
	
	if (!sideButton || !sideButton.classList.contains('select')) {
		console.log('‚ùå Item not selected or button not found');
		return;
	}
	
	const config = window.sideCategoryConfigs[categoryName];
	if (!config) {
		console.error(`‚ùå No config found for category: ${categoryName}`);
		return;
	}
	
	const maxItems = config.all_max || 99;
	
	// Find the overlay for this category (NEW structure)
	const overlayId = `itemSideControl_${categoryName}`;
	const overlay = document.getElementById(overlayId);
	
	if (!overlay) {
		console.error(`‚ùå Overlay not found: ${overlayId}`);
		return;
	}
	
	// Get all selected items within this overlay
	const selectedItems = overlay.querySelectorAll('.btn-side-option.select');
	
	// Calculate total quantity
	let totalQuantity = 0;
	selectedItems.forEach(item => {
		const itemParent = item.parentElement;
		const itemQty = itemParent.querySelector('b');
		totalQuantity += itemQty ? parseInt(itemQty.innerText) || 1 : 1;
	});
	
	console.log(`üìä Current total: ${totalQuantity}, Max: ${maxItems}`);
	
	if (totalQuantity < maxItems) {
		const currentQty = quantityDisplay ? parseInt(quantityDisplay.innerText) || 1 : 1;
		const itemName = sideButton.dataset.itemName;
		
		// Remove old entry from global order
		const oldName = `${currentQty} ${itemName}`;
		const index = orderSides.indexOf(oldName);
		if (index > -1) {
			orderSides.splice(index, 1);
		}
		
		// Remove old entry from category tracking
		if (categorySidesTracking[categoryName]) {
			const catIndex = categorySidesTracking[categoryName].indexOf(oldName);
			if (catIndex > -1) {
				categorySidesTracking[categoryName].splice(catIndex, 1);
			}
		}
		
		// Update quantity
		if (quantityDisplay) {
			quantityDisplay.innerText = currentQty + 1;
		}
		
		// Add new entry with updated quantity
		addSideItem(sideButton, categoryName);
		
		console.log(`‚¨ÜÔ∏è Increased quantity for ${itemName} to ${currentQty + 1}`);
	} else {
		console.log(`‚ö†Ô∏è Cannot add more - at maximum (${maxItems})`);
		alert(`You can only select ${maxItems} item(s) total.`);
	}
}

// Function to open side categories menu
function openSideCategoriesMenu() {
	const con = document.getElementById("itemSideControl");
	
	// Open the overlay
	if (con.classList.contains('hide')) {
		con.classList.remove('hide');
	}
	
	console.log('üé® Side categories menu opened');
}

// Function to close side categories menu
function closeSideCategoriesMenu() {
	const list = document.getElementById("sideList");
	const con = document.getElementById("itemSideControl");
	
	// Update the summary list
	list.innerText = printArray(orderSides);
	
	// Close the overlay
	if (!con.classList.contains('hide')) {
		con.classList.add('hide');
	}
	
	console.log('‚úÖ Side categories menu closed, selections:', orderSides);
}

function makeModificationsHtml(modificationsHtml,index) {
	console.log(index+' modificationsHtml:- '+modificationsHtml);
	if(currentoptions.modifications.length>index){
		console.log(currentoptions.modifications.length+'>'+index);
		modificationsHtml = modificationsHtml+'<a class="btn-mod-option" onclick="selectToggle(this);ModPrice(this,'+currentoptions.modifications[index+1]+');">'+currentoptions.modifications[index]+'</a><b class="hide">$'+currentoptions.modifications[index+1]+'</b>'
		makeModificationsHtml(modificationsHtml,index+2);
	} else {
		document.getElementById("itemMods").innerHTML='<h3 class="title center main-text-color">Modifications</h3><div>'+modificationsHtml+'</div><button class="btn-close-menu" onclick="openModMenu();">Confirm</button>';
		document.getElementById("itemModContainer").classList.remove("hide");
	}

}

function makeAdditionsHtml(additionsHtml,index) {
	console.log(index+' additionsHtml:- '+additionsHtml);
	if(currentoptions.additions.length>index){
		console.log(currentoptions.sides.length+'>'+index);
		additionsHtml = additionsHtml+'<a class="btn-add-option" onclick="selectToggle(this);AddPrice(this,'+currentoptions.additions[index+1]+');'+'">'+currentoptions.additions[index]+'</a><b class="hide">$'+currentoptions.additions[index+1]+'</b>'
		makeAdditionsHtml(additionsHtml,index+2);
	} else {
		document.getElementById("itemAddMods").innerHTML ='<h3 class="title center main-text-color">Additional Modifications</h3><div>'+additionsHtml+'</div><button class="btn-close-menu" onclick="openAddMenu();">Confirm</button>';
		document.getElementById("itemAddContainer").classList.remove("hide");
	}

}

function makeSidesHtml(sideHtml,index) {
	console.log(index+' Sides HTML:- '+sideHtml);
	if(currentoptions.sides.length>index){
		console.log(currentoptions.sides.length+'>'+index);
		if(currentoptions.sides[index+1]=='Regular'){
			sideHtml = sideHtml+'<b class="hide">1</b><a class="btn-side-option regularside" onclick="selectAmt(this);">'+currentoptions.sides[index]+'</a><p class="btn-add-extra hide" onclick="addExtra(this);"><i class="fa fa-plus"></i></p>';
		}else if(currentoptions.sides[index+1]=='Premium'){
			sideHtml = sideHtml+'<b class="hide">1</b><a class="btn-side-option premiumside" onclick="selectAmt(this);">'+currentoptions.sides[index]+' <i class="fa fa-star"></i></a><p class="btn-add-extra" onclick="addExtra(this);" class="btn-add-extra hide"><i class="fa fa-plus"></i></p>';	
		}
		makeSidesHtml(sideHtml,index+3);
	} else {
		// Create legacy overlay inside itemSideControl container
		const overlayHtml = `
			<div id="itemSideControl_legacy" class="hide fadein">
				<div class="container">
					<div id="itemSides">
						<h3 class="title center main-text-color">Sides</h3>
						<div>${sideHtml}</div>
						<button class="btn-close-menu" onclick="openSideMenu();">Confirm</button>
					</div>
				</div>
			</div>
		`;
		document.getElementById("itemSideControl").innerHTML = overlayHtml;
		document.getElementById("itemSideContainer").classList.remove("hide");
	}

}

function addSides(ele){
	if (ele.classList.contains('select')){
		// console.log("ADD SIDE: "+ele.previousSibling.innerText+" "+ele.innerText);
		orderSides.push(ele.previousSibling.innerText+" "+ele.innerText);
		if(ele.classList.contains('regularside')){
			regAmt=regAmt+1;
			if(regAmt>=currentoptions.sideoptions[4]){
				sidePrice=sidePrice+currentoptions.sideoptions[5];
			}
		}else if(ele.classList.contains('premiumside')){
			premAmt=premAmt+1;
			if(premAmt>=currentoptions.sideoptions[7]){
				sidePrice=sidePrice+currentoptions.sideoptions[8];
			}
		}

	}
	// console.log(orderSides);
	updatePrices();
}

function removeSides(ele){
	if (ele.classList.contains('select')){
		if(ele.classList.contains('regularside')){
			if(regAmt>=currentoptions.sideoptions[4]){
				sidePrice=sidePrice-currentoptions.sideoptions[5];
			}
			regAmt=regAmt-parseInt(ele.previousSibling.innerText);

		}else if(ele.classList.contains('premiumside')){
			if(regAmt>=currentoptions.sideoptions[7]){
				sidePrice=sidePrice-currentoptions.sideoptions[8];
			}
			premAmt=premAmt-parseInt(ele.previousSibling.innerText);
		}
		// console.log("REMOVE SIDE: "+ele.previousSibling.innerText+" "+ele.innerText);
		var index = orderSides.indexOf(ele.previousSibling.innerText+" "+ele.innerText);
		orderSides.splice(index,1);
		ele.classList.remove('select');
		ele.previousSibling.classList.add('hide')
		ele.previousSibling.innerText=1;
	 	ele.nextSibling.classList.add('hide')
	 	
	}
	// console.log(orderSides);
	updatePrices();
}

function addExtra(ele){
	var selEle = ele.parentElement.getElementsByClassName('select');
	var num = 0;
		for (var i = 0; i<=selEle.length - 1;  i++) {
			num = num + parseInt(selEle[i].previousSibling.innerText);
		}
		if(num<currentoptions.sideoptions[0]){
			if(selEle.length<(currentoptions.sideoptions[0]) && parseInt(ele.previousSibling.previousSibling.innerText)<(currentoptions.sideoptions[0])){
				// console.log(orderSides);
				// console.log("SPLICE: "+(ele.previousSibling.previousSibling.innerText+" "+ele.previousSibling.innerText));
				var index = orderSides.indexOf(ele.previousSibling.previousSibling.innerText+" "+ele.previousSibling.innerText);
				orderSides.splice(index,1);
				// console.log(orderSides);
				ele.previousSibling.previousSibling.innerText=parseInt(ele.previousSibling.previousSibling.innerText)+1;
				addSides(ele.previousSibling);
			}
		}

}

function AddPrice(ele,i){
	if (ele.classList.contains('select')){
		addPrice = addPrice+i;

		orderAdd.push(ele.innerText);
	}else{
		addPrice = addPrice-i;
		var index = orderAdd.indexOf(ele.innerText);
		orderAdd.splice(index,1);
	}
	if(addPrice<0){
		addPrice = 0;
	}
	//console.log("AddPrice");
	updatePrices();
}

function ModPrice(ele,i){
	if (ele.classList.contains('select')){
		modPrice = modPrice+i;
		orderMod.push(ele.innerText);
		ele.nextSibling.classList.remove('hide');
	}else{
		modPrice = modPrice-i;
		var index = orderMod.indexOf(ele.innerText);
		orderMod.splice(index,1);
		ele.nextSibling.classList.add('hide');
	}
	//console.log("ModPrice");
	updatePrices();
}

function lineCostCalc(ele,i){
	var linecost=0;
	if(ele.classList.contains('select')){
		linecost = +i;
	}else{
		linecost = -i;
	}
	document.getElementById("itemPrice").innerText=('$'+(basePrice+addPrice+modPrice));
	//console.log("lineCostCalc");
	updatePrices();
}

function itemAmtCalc(value){
	var myAmt = document.getElementById("itemAmt");
	var newValue = parseInt(myAmt.innerText);
	newValue=newValue + value;
	if(newValue>0){
		myAmt.innerText = newValue;	
	}
	//console.log("itemAmtCalc");
	updatePrices();
}


function setBasePrice(index){
	if(currentoptions.items.length>index){
		if(currentoptions.items[index]==orderSize){
			console.log("CurrentSize :"+ orderSize+"|"+ currentoptions.items[index])

			if(currentoptions.items[index+1]==orderFlav){
				console.log("Current Flav :"+ orderFlav +"|"+currentoptions.items[index+1])
				basePrice=currentoptions.items[index+2];
				return;
			}else{
				console.log("!No Match Flav:"+ orderFlav +"|"+currentoptions.items[index+1])
				index=index+3;
				setBasePrice(index);
			}

		}else{
			console.log("!No Match Size:"+orderSize+"|"+currentoptions.items[index])
			index=index+3;
			setBasePrice(index);
		}

	}
	updatePrices();
}

function setBaseSize(ele){
	orderSize = ele.innerText;
	// console.log("setVaseSize :"+orderSize);
	selectOnly(ele);
	setBasePrice(0);
	updatePrices();
}

function setBaseFlav(ele){
	orderFlav = ele.innerText;
	// console.log("setBaseFlav :"+orderFlav);
	selectOnly(ele);
	setBasePrice(0);
	updatePrices();
}

function updatePrices(){
	document.getElementById("itemPrice").innerText=('$'+(basePrice+sidePrice+addPrice+modPrice));
	document.getElementById("itemAddCart").innerHTML=('<i class="fa fa-cart-plus"></i> '+(basePrice+sidePrice+addPrice+modPrice));

	var lineCost = parseInt(document.getElementById("itemAmt").innerText)*(basePrice+sidePrice+addPrice+modPrice);
	document.getElementById("itemAddCart").innerHTML=('<i class="fa fa-cart-plus"></i> $'+lineCost);

	// Convert arrays to JSON, but for sides include category tracking
	var sidesData = JSON.stringify({
		items: orderSides,
		categories: categorySidesTracking
	});
	var addsJson = JSON.stringify(orderAdd);
	var modsJson = JSON.stringify(orderMod);
	
	var funcText = 'addItem("'+document.getElementById("itemName").innerText+'","'+orderSize+' '+orderFlav+'",'+sidesData+','+addsJson+','+modsJson+',"'+document.getElementById("itemAmt").innerText+'",'+lineCost+');';
	document.getElementById("itemAddCart").setAttribute( "onclick", funcText);

	//console.log(funcText);
	//console.log(orderMod);
}

function addFocus(ele){
 	var selEle = document.getElementsByClassName('selected');
 	for (var i = selEle.length - 1; i >= 0; i--) {
 		selEle[i].classList.remove('selected');
 	}
 	ele.classList.add('selected');
}

function selectOnly(ele){
	if(!ele.classList.contains('select')){
		var selEle = ele.parentElement.getElementsByClassName('select')
	 	for (var i = selEle.length - 1; i >= 0; i--) {
	 		selEle[i].classList.remove('select');
	 	}
		ele.classList.add('select');
	}
}

function selectToggle(ele){
	if(ele.classList.contains('select')){
		ele.classList.remove('select');
	}else{
		ele.classList.add('select');
		//add text to order
	}
	return ele.classList.contains('select');
}

function selectAmt(ele){
	if(ele.classList.contains('select')){
		removeSides(ele);
	}else{
		var selEle = ele.parentElement.getElementsByClassName('select');
		var num = 0;
		for (var i = 0; i<=selEle.length - 1;  i++) {
			num = num + parseInt(selEle[i].previousSibling.innerText);
		}
		if (num<currentoptions.sideoptions[0] && selEle.length<currentoptions.sideoptions[0]){
					num = num+1;
					ele.classList.add('select');
					addSides(ele);
		 			ele.previousSibling.classList.remove('hide');
		 			ele.nextSibling.classList.remove('hide');
		}
	}	
}

function itemAmtCalc(value){
	var myAmt = document.getElementById("itemAmt");
	var newValue = parseInt(myAmt.innerText);
	newValue=newValue + value;
	if(newValue>0){
		myAmt.innerText = newValue;	
	}
	//console.log("itemAmtCalc");
	updatePrices();
}


// CART

function toggleCart(){
    var cart = document.getElementById("cart");
    var footerBtns = document.getElementById("footerBtns");
    if(cart.classList.contains('cart-hidden')){
      cart.classList.remove('cart-hidden');
      footerBtns.classList.add('bigfont');
      footerBtns.classList.add('cartopen');
      footerBtns.classList.remove('smallfont');
      footerBtns.classList.add('grad1');
      footerBtns.classList.remove('grad2');
    }else{
      cart.classList.add('cart-hidden');
      footerBtns.classList.remove('cartopen');
      footerBtns.classList.add('grad2');
      footerBtns.classList.remove('grad1');
      footerBtns.classList.remove('bigfont');
      footerBtns.classList.add('smallfont');
      
    }
  }
  function closeCart(){
    var cart = document.getElementById("cart");
    var footerBtns = document.getElementById("footerBtns");
    cart.classList.add('cart-hidden');
    footerBtns.classList.remove('cartopen');
    footerBtns.classList.add('grad2');
    footerBtns.classList.remove('grad1');
    footerBtns.classList.remove('bigfont');
    footerBtns.classList.add('smallfont');
	}

	function saveCart() {
		const baseURL = window.location.origin;
		localStorage.setItem('menu', JSON.stringify(baseURL));
	  localStorage.setItem('cart', JSON.stringify(order));
	  console.log(localStorage.getItem('cart'));
	}

	function loadCart() {
		const savedMenu = localStorage.getItem('menu');
		const baseURL = window.location.origin;
		if (savedMenu == JSON.stringify(baseURL) ){
		  const savedCart = localStorage.getItem('cart');
		  if (savedCart) {
		    order = JSON.parse(savedCart);
		    console.log(order);
		    buildOrderText(); // Refresh the cart UI with the loaded data
		  }
	  }
	}

  function addItem(item,size,sides,adds,mods,amt,cost){
  // Handle new structure with category tracking
  let sidesData = sides;
  
  // If sides is an object with categories, use it directly
  if (typeof sides === 'object' && sides !== null && !Array.isArray(sides) && sides.categories) {
    sidesData = sides; // Already in correct format
  }
  // If sides is an array (old format), convert to new format
  else if (Array.isArray(sides)) {
    sidesData = {
      items: sides,
      categories: { 'Sides': sides } // Default category name
    };
  }
  // If sides is a string (backward compatibility)
  else if (typeof sides === 'string' && sides.trim() !== '') {
    const sidesArray = sides.split(',').map(s => s.trim()).filter(s => s);
    sidesData = {
      items: sidesArray,
      categories: { 'Sides': sidesArray }
    };
  }
  // Empty sides
  else {
    sidesData = {
      items: [],
      categories: {}
    };
  }
  
  // Handle adds and mods (arrays)
  let addsArray = Array.isArray(adds) ? adds : [];
  let modsArray = Array.isArray(mods) ? mods : [];
  
  if (typeof adds === 'string' && adds.trim() !== '') {
    addsArray = adds.split(',').map(s => s.trim()).filter(s => s);
  }
  if (typeof mods === 'string' && mods.trim() !== '') {
    modsArray = mods.split(',').map(s => s.trim()).filter(s => s);
  }
  
  console.log('üì¶ Adding to cart:', {item, sidesData, adds: addsArray, mods: modsArray});
  
  order.push({"item":item,"size":size,"sides":sidesData,"adds":addsArray, "mods":modsArray, "amt":amt,"cost":cost});
  additemtocart();
  cartadditem();
  buildOrderText();
  saveCart();
  updateCart(1);
  
  // Track add to cart event
  if (typeof window.trackAddToCart === 'function') {
    window.trackAddToCart({
      name: item,
      title: item,
      price: cost / amt, // Base price per unit
      category: 'Menu Item'
    }, amt, cost);
  }
  
  //openCart();
  //printValues();
}
function additemtocart(){
  let modal = document.getElementById("orderModal");
  modal.classList.add("additemtocart");
  setTimeout(()=>{
  			closeShop();
        modal.classList.remove("additemtocart");
  },             500);  
   
} 
function cartadditem(){
  let cart = document.getElementById("carticon");
  cart.classList.add("cartadditem");
  setTimeout(()=>{
        cart.classList.remove("cartadditem");
  },             500);  
   
} 
function removeItem(i){
	// Track removal before removing
	if (typeof window.trackRemoveFromCart === 'function' && order[i]) {
		const removedItem = order[i];
		window.trackRemoveFromCart({
			name: removedItem.item,
			title: removedItem.item,
			price: removedItem.cost
		}, price); // price is the global cart total
	}
	
	order.splice(i,1);
	buildOrderText();
	saveCart();
	updateCart(-1);
	//printValues();
}
function removeAllItems(){
	order=[];
	var c =order.index-1;
	order=[];
	localStorage.removeItem('cart');  // Clear cart from localStorage
	buildOrderText();
	document.getElementById("cartcount").innerText= 0;
  updateCart(0);
	//printValues();
}

function updateCart(i){
    var cart = document.getElementById("cartcount");
    cart.innerText= parseInt(cart.innerText)+i;
    
    if(parseInt(cart.innerText)<=0){
    	cart.classList.add('hide');
    }else{
    	cart.classList.remove('hide');
    }
}

function buildOrderText(){
	messageBody='';
	var itemSides='';
	var itemAdds='';
	var itemMods='';
	var orderHtml='<tr><th id="itemNo">#</th><th>Size</th><th>Item</th><th>Amt</th><th>Cost</th><th style="text-align: center;"><a style="font-size: medium;" onclick="removeAllItems();"><i class="fa fa-trash-o"></i></a></th></tr>';

	for (var i = 0; i <= order.length-1; i++) {
		// Reset variables for each item
		itemSides='';
		itemAdds='';
		itemMods='';
		
		// Handle sides with category tracking (new format)
		if (order[i].sides && typeof order[i].sides === 'object' && order[i].sides.categories) {
			const categories = order[i].sides.categories;
			const categoryNames = Object.keys(categories);
			
			if (categoryNames.length > 0) {
				const categoryStrings = [];
				categoryNames.forEach(function(catName) {
					const catItems = categories[catName];
					if (catItems && catItems.length > 0) {
						let catStr = catName + ': ';
						for (var j = 0; j < catItems.length; j++) {
							catStr += catItems[j];
							if (j < catItems.length - 1) {
								catStr += ', ';
							}
						}
						categoryStrings.push(catStr);
					}
				});
				itemSides = categoryStrings.join('\n');
			}
		}
		// Handle old format (array)
		else if (order[i].sides && order[i].sides.length>0){
			itemSides = 'Sides: ';
			for (var j = 0; j <= order[i].sides.length-1; j++) {
			 itemSides=itemSides+order[i].sides[j];
			 if (j < order[i].sides.length-1) {
			 	itemSides=itemSides+', ';
			 }
			}
		}

		if (order[i].adds.length>0){
			itemAdds = 'Additional Mods: ';
			for (var j = 0; j <= order[i].adds.length-1; j++) {
			 itemAdds=itemAdds+order[i].adds[j];
			 if (j < order[i].adds.length-1) {
			 	itemAdds=itemAdds+', ';
			 }
			}
		}

		if (order[i].mods.length>0){
			itemMods = 'Mods: ';
			for (var j = 0; j <= order[i].mods.length-1; j++) {
			 	itemMods=itemMods+order[i].mods[j];
			 	if (j < order[i].mods.length-1) {
			 		itemMods=itemMods+', ';
			 	}
			}
		}

		messageBody=messageBody+'#'+(i+1)+' | '+order[i].size+' '+order[i].item+' | Qty'+order[i].amt+' $'+order[i].cost+printArraySides(i,itemSides)+printArrayMods(i,itemMods)+printArrayAdds(i,itemAdds)+'\n\n';

		//CUSTOM MESSAGE BODY
		//messageBody='#'+messageBody+(i+1)+' | '+'Qty'+order[i].amt+' | '+order[i].size+' '+order[i].item+' $'+order[i].cost+printArraySides(i,itemSides)+printArrayAdds(i,itemAdds)+printArrayMods(i,itemMods)+'\n';
		orderHtml = (orderHtml+'<tr><td id="itemNo">'+(i+1)+'</td><td id="itemSize">'+order[i].size+'</td><td id="itemDesc">'+order[i].item+printHtmlArraySides(i,itemSides)+printHtmlArrayMods(i,itemMods)+printHtmlArrayAdds(i,itemAdds)+'\n'+'</td><td>'+order[i].amt+' </td><th id="itemCost">$'+order[i].cost+'</th><td id="itemXBtn"><a onclick="removeItem('+i+');"><i class="fa fa-close"></i></a></td></tr>');
		// console.log(orderHtml);
	}

	priceCalc();
	vatCalc();
	serviceCalc();
	document.getElementById("whatsappOrder").innerHTML=orderHtml;
	
	// Build card-based UI
	buildCartCards();
	
	if(vat>0 || service>0){
		document.getElementById("subTotal").innerText=(price.toFixed(2));
		document.getElementById("subTotalcontainer").classList.remove('hide');
		
	}else {
		document.getElementById("subTotalcontainer").classList.add('hide');
	}
	if(vat>0){
			document.getElementById("vat").innerText=('V.A.T. '+vat*100+'% $');
			document.getElementById("vatCalc").innerText=(vatcost.toFixed(2));
			document.getElementById("vatCalccontainer").classList.remove('hide');
	}else{
		document.getElementById("vatCalccontainer").classList.add('hide');
	}
	if(service>0){
		document.getElementById("service").innerText=('Service Charge '+service*100+'% $');
		document.getElementById("serviceCalc").innerText=(servicecost.toFixed(2));
		document.getElementById("serviceCalccontainer").classList.remove('hide');
	}else{
		document.getElementById("serviceCalccontainer").classList.add('hide');
	}
	var displayTotal=(price+vatcost+servicecost);
	document.getElementById("itemTotal").innerText=('TOTAL $'+displayTotal.toFixed(2));
	constructWAMessage();
}

function buildCartCards() {
	const cartContainer = document.getElementById("cartItemsContainer");
	const emptyState = document.getElementById("cartEmptyState");
	
	if (!cartContainer) return;
	
	// Show/hide empty state
	if (order.length === 0) {
		if (emptyState) emptyState.style.display = 'flex';
		cartContainer.innerHTML = '';
		return;
	}
	
	if (emptyState) emptyState.style.display = 'none';
	
	// Build card HTML for each item
	let cardsHtml = '';
	
	for (let i = 0; i < order.length; i++) {
		const item = order[i];
		let itemSides = '';
		let itemAdds = '';
		let itemMods = '';
		let hasDetails = false;
		
		// Handle sides with category tracking (new format)
		if (item.sides && typeof item.sides === 'object' && item.sides.categories) {
			const categories = item.sides.categories;
			const categoryNames = Object.keys(categories);
			
			if (categoryNames.length > 0) {
				hasDetails = true;
				const categoryStrings = [];
				categoryNames.forEach(function(catName) {
					const catItems = categories[catName];
					if (catItems && catItems.length > 0) {
						categoryStrings.push(`<div class="cart-item-category"><strong>${catName}:</strong> ${catItems.join(', ')}</div>`);
					}
				});
				itemSides = categoryStrings.join('');
			}
		}
		// Handle old format (array)
		else if (item.sides && item.sides.length > 0) {
			hasDetails = true;
			itemSides = `<div class="cart-item-category"><strong>Sides:</strong> ${item.sides.join(', ')}</div>`;
		}
		
		if (item.adds && item.adds.length > 0) {
			hasDetails = true;
			itemAdds = `<div class="cart-item-category"><strong>Additional Mods:</strong> ${item.adds.join(', ')}</div>`;
		}
		
		if (item.mods && item.mods.length > 0) {
			hasDetails = true;
			itemMods = `<div class="cart-item-category"><strong>Modifications:</strong> ${item.mods.join(', ')}</div>`;
		}
		
		// Build the card with collapsible feature
		cardsHtml += `
			<div class="cart-item-card collapsed" data-item-index="${i}">
				<div class="cart-item-header">
					<div class="cart-item-number">#${i + 1}</div>
					<button class="cart-item-remove" onclick="event.stopPropagation(); removeItem(${i});" title="Remove item">
						<i class="fa fa-times"></i>
					</button>
				</div>
				<div class="cart-item-body" onclick="toggleCartItem(${i})">
					<div class="cart-item-main-info">
						<div class="cart-item-name-row">
							<div class="cart-item-name">${item.item}</div>
							${hasDetails ? '<i class="fa fa-chevron-down cart-expand-icon"></i>' : ''}
						</div>
						${item.size ? `<div class="cart-item-size">${item.size}</div>` : ''}
					</div>
					${hasDetails ? `
						<div class="cart-item-details">
							${itemSides}
							${itemMods}
							${itemAdds}
						</div>
					` : ''}
				</div>
				<div class="cart-item-footer">
					<div class="cart-item-quantity">
						<i class="fa fa-times" style="font-size: 0.8em; opacity: 0.7;"></i> ${item.amt}
					</div>
					<div class="cart-item-price">$${item.cost.toFixed(2)}</div>
				</div>
			</div>
		`;
	}
	
	cartContainer.innerHTML = cardsHtml;
}

// Toggle individual cart item expansion
function toggleCartItem(index) {
	const card = document.querySelector(`.cart-item-card[data-item-index="${index}"]`);
	if (card) {
		card.classList.toggle('collapsed');
	}
}

function openSideMenu() {
	var list = document.getElementById("sideList");
	var con = document.getElementById("itemSideControl_legacy");
	if (!con) return; // Safety check
	if (list) list.innerText = printArray(orderSides);
	
	if(con.classList.contains('hide')){
		con.classList.remove('hide');
	}else{
		con.classList.add('hide');
	}
}

function openAddMenu() {
	var list = document.getElementById("addModList");
  var con = document.getElementById("itemAdditionControl");
  list.innerText=printArray(orderAdd);
     if(con.classList.contains('hide')){
      con.classList.remove('hide');
    }else{
      con.classList.add('hide');
    }
}

function openModMenu() {
	var list = document.getElementById("modList");
  var con = document.getElementById("itemModControl");
  list.innerText=printArray(orderMod);
     if(con.classList.contains('hide')){
      con.classList.remove('hide');
    }else{
      con.classList.add('hide');
    }
}

function printArray(arr){
 	var mod = '';
 	for (var j = 0; j <= arr.length-1; j++) {
			 	mod=mod+'- '+arr[j]+'\n';
			}
	return mod;
 }

function printHtmlArraySides(i,itemSides){
	// Check both new and old formats
	const hasSides = (order[i].sides && order[i].sides.categories && Object.keys(order[i].sides.categories).length > 0) ||
	                 (order[i].sides && order[i].sides.length > 0);
	
	if (hasSides && itemSides){
		// Replace newlines with <br> for HTML display
		const htmlSides = itemSides.replace(/\n/g, '<br>');
		return ('<br>'+htmlSides);
	}else return '';
}
function printHtmlArrayAdds(i,itemAdds){
	if (order[i].adds.length>0){
		return ('<br>'+itemAdds);
	}else return '';
}
function printHtmlArrayMods(i,itemMods){
	if (order[i].mods.length>0){
		return ('<br>'+itemMods);
	}else return '';
}

function printArraySides(i,itemSides){
	// Check both new and old formats
	const hasSides = (order[i].sides && order[i].sides.categories && Object.keys(order[i].sides.categories).length > 0) ||
	                 (order[i].sides && order[i].sides.length > 0);
	
	if (hasSides && itemSides){
		return ('\n'+itemSides);
	}else return '';
}

function printArrayAdds(i,itemAdds){
	if (order[i].adds.length>0){
		return ('\n'+itemAdds);
	}else return '';
}

function printArrayMods(i,itemMods){
	if (order[i].mods.length>0){
		return ('\n'+itemMods);
	}else return '';
}

function priceCalc(){
	price = 0;
	for (var i = 0; i <= order.length-1; i++) {
		price=price+order[i].cost;
	}
}

function vatCalc(){
	vatcost=parseFloat((price*vat).toFixed(2));
}
function serviceCalc(){
	servicecost=parseFloat((price*service).toFixed(2));
}


function advanceOrder(){
	if (hastables) {
	
		// Get the currently selected location from dropdown
		const currentLocationData = getCurrentLocationData();
		if (currentLocationData) {
			// Close the cart first
			closeCart();
			openTableModalWithLocation(currentLocationData);
		} else {
			// No location selected, show alert
			alert('Please select a location first before placing your order.');
			return;
		}
	}else{
		// Close the cart first
		closeCart();
		confirm();
	}
}

// Function to get location data from dropdown (simplified version)
function getLocationDataFromElement(locationElement) {
	// This function is kept for compatibility but now uses dropdown data
	return getCurrentLocationData();
}

// Function to open table modal with specific location data
function openTableModalWithLocation(locationData) {
    if (!locationData) {
        console.error('‚ùå No location data provided');
        return;
    }
    
    // Store the selected location data
    selectedLocationData = locationData;
    
    // Update the display with location info
    updateSelectedLocationDisplay(locationData);
    
    // Populate table numbers
    populateTableNumbers(locationData);
    
    // Show the table selection section
    const tableSelectionSection = document.getElementById('tableSelectionSection');
    if (tableSelectionSection) {
        tableSelectionSection.classList.add('show');
    }
    
    // Show the modal
    document.getElementById('tableNumberModal').classList.remove('hide');
}

// Function to set table number from external sources (like table modal)
function setTableNumber(tableNumber) {
	console.log('üéØ Setting table number to:', tableNumber);
	myTable = tableNumber;
	
	// Update the cart display if needed
	updateCartLocationDisplay();
}

// Function to update cart location display with table info
function updateCartLocationDisplay() {
	const cartLocationDiv = document.getElementById('cartLocation');
	if (cartLocationDiv) {
		const currentLocation = getVisibleLocation();
		if (currentLocation) {
			const locationText = currentLocation.textContent.trim();
			let displayText = `üìç ${locationText}`;
			
			// Add table number if available
			if (myTable && myTable.trim() !== '') {
				displayText += ` - Table ${myTable}`;
			}
			
			cartLocationDiv.innerHTML = displayText;
			cartLocationDiv.classList.add('active');
		}
	}
}

function confirm(){
	constructWAMessage();
	confirmSendOrder();
}

function constructWAMessage(){
	var subTotalTxt='';
	var vatTxt='';
	var servicext='';
	var label='';
	
	// Determine the correct label based on global order type variables
	if (currentOrderType === 'takeaway') {
		label = 'Takeaway';
	} else if (currentOrderType === 'table' && currentTableNumber && currentTableNumber.trim() !== '') {
		label = `Table #${currentTableNumber}`;
	} else {
		label = 'Takeaway'; // Default fallback
	}
	
	if(vat>0 || service>0){
		subTotalTxt='\nSub Total $ '+price.toFixed(2);
		if(vat>0){
			vatTxt='\nV.A.T. '+vat*100+'% $ '+vatcost.toFixed(2);
		}
		if(service>0){
			servicext='\nService Charge '+service*100+'% $ '+servicecost.toFixed(2);
		}
	}
	
	message = 'https://wa.me/'+number+'?text='+encodeURIComponent(messageStart+label+'\n'+messageBody+subTotalTxt+vatTxt+servicext+'\nTOTAL $'+(price+vatcost+servicecost)+messageEnd);
}

function confirmSendOrder(){
	// Track order submission
	if (typeof window.trackOrderSubmission === 'function') {
		const locationSelect = document.getElementById('locationSelect');
		const selectedLocation = locationSelect ? locationSelect.options[locationSelect.selectedIndex]?.text : 'Unknown';
		
		window.trackOrderSubmission({
			items: order,
			totalAmount: price + vatcost + servicecost,
			orderMode: currentOrderType || currentMode || 'unknown',
			location: selectedLocation,
			tableNumber: currentTableNumber || myTable || null
		});
	}
	
	window.open(message, "_blank" );
	
	// Process order with POS system if enabled
	if (window.posIntegration && window.posIntegration.isPOSEnabled) {
		window.posIntegration.processOrderWithPOS();
	}
	
	// Clear the order type variables after sending the order
	currentOrderType = 'takeaway';
	currentTableNumber = '';
}

//Dine modes
function toggleDiningMode(ele){
  if (ele.checked == true){
    selectMode(1);
   
  } else{
    selectMode(0);
    
  }
}
function selectMode(i){
  currentMode = modes[i].name;
  //var checkBox1 = document.getElementById("dining-mode-checkbox-1");
  var checkBox2 = document.getElementById("dining-mode-checkbox-2");
  if(i==1){
  	//checkBox1.checked=true;
  	checkBox2.checked=true;
  	service=0.0;
  }else{
  	//checkBox1.checked=false;
  	checkBox2.checked=false;
  	myTable='';
  	service=0.0;
  }
  //console.log(modes[i].name);
  executeMode();
  buildOrderText();
}


function executeMode(){
	var cart=document.getElementById('cart')
	//cart.classList.remove('cartexpanded');
	//document.getElementById('titleRow').innerHTML='<i class="fa fa-arrow-right"></i> '+currentMode; 
	var server=document.getElementById('askforserver');
	if (currentMode=='dinein'){
		server.classList.remove("hide");
	}else{
		server.classList.add("hide");
	}
  // var ele = document.getElementsByClassName('takeawayonly');
  
  // if (currentMode==modes[0].name){
  //   document.getElementById('takeaway').classList.add('active');
  //   document.getElementById('dinein').classList.remove('active');
  //   // for (var i = ele.length - 1; i >= 0; i--) {
  //   //   ele[i].classList.remove('hide');
  //   // }
  // }else{
  //   // for (var i = ele.length - 1; i >= 0; i--) {
  //   //   ele[i].classList.add('hide');
  //   // }
  //   document.getElementById('dinein').classList.add('active');
  //   document.getElementById('takeaway').classList.remove('active');
  // }
  
 }

function executeModeOnModal(){
  
  // if (currentMode=='dinein'){
  //   var ele = document.getElementById('itemSizeControl').getElementsByTagName("a");
  //   for (var i = ele.length - 1; i >= 0; i--) {
  //     if(ele[i].innerText.substring(0, 1)=="S"){
  //         ele[i].classList.add('hide');
  //         ele[i].classList.remove('select');
  //     }else{
  //         selectOnly(ele[i]);
  //         setBaseSize(ele[i]);
  //     }

  //   }
  // }
}

function executeModeOnTableModal(){	
	var ele1 = document.getElementsByClassName('tableBtn');
	var ele2 = document.getElementsByClassName('takeawayBtn');
	if (currentMode=='takeaway'){
		ele2[0].classList.remove('hide');
		ele2[0].classList.remove('select');
		for (var i = ele1.length - 1; i >= 0; i--) {
     		ele1[i].classList.add('hide');
          	ele1[i].classList.remove('select');
        }
	}else if (currentMode=='dinein'){
		ele2[0].classList.add('hide'); 
		ele2[0].classList.remove('select');   	
		for (var i = ele1.length - 1; i >= 0; i--) {
     		ele1[i].classList.remove('select');
          	ele1[i].classList.remove('hide');
        }
	}
}

function cartSizeToggle(){
	 var cart=document.getElementById('cart')
	 if (cart.classList.contains('cartexpanded')){
	 	cart.classList.remove('cartexpanded');
	 	document.getElementById('titleRow').innerHTML='<i class="fa fa-arrow-right"></i> Order';
	 }else{
	 	cart.classList.add('cartexpanded');
	 	document.getElementById('titleRow').innerHTML='<i class="fa fa-arrow-down"></i> Order';
	 }
}	

function openTableModal(state){
	closeCart();
	if (state=='askforserver'){
		document.getElementById("tableNumberModal").classList.remove('hide');
		document.getElementById("confirmmodal").classList.add('hide');
		document.getElementById("askforservermodal").classList.remove('hide');
		//executeModeOnTableModal();
	}else if (currentMode=='takeaway'){
		confirm();
		return;
	}else{
		document.getElementById("tableNumberModal").classList.remove('hide');
		document.getElementById("askforservermodal").classList.add('hide');
		document.getElementById("confirmmodal").classList.remove('hide');
		//executeModeOnTableModal();
	}
	
}
function closeTableModal() {
    document.getElementById('tableNumberModal').classList.add('hide');
    document.getElementById('confirmmodal').classList.remove('show');
    document.querySelector('.input').classList.remove('hide');
    
    // Hide the table selection section
    const tableSelectionSection = document.getElementById('tableSelectionSection');
    if (tableSelectionSection) {
        tableSelectionSection.classList.remove('show');
    }
    
    // Remove selected class from all table buttons
    const allTableButtons = document.querySelectorAll('.tableBtn');
    allTableButtons.forEach(btn => btn.classList.remove('selected'));
    
    // Hide the order summary display
    const orderSummaryDisplay = document.getElementById('orderSummaryDisplay');
    if (orderSummaryDisplay) {
        orderSummaryDisplay.classList.add('hide');
    }
    
    // Clear the order summary display
    const summaryLocationInfo = document.getElementById('summaryLocationInfo');
    if (summaryLocationInfo) {
        summaryLocationInfo.innerHTML = '';
    }
    
    // Reset selected table info
    window.selectedTableInfo = null;
    selectedLocationData = null;
    
    // Clear the current order location
    window.currentOrderLocation = null;
}

// Enhanced selectTable function to include location context
function selectTable(buttonElement) {
    if (!selectedLocationData) {
        console.error('‚ùå No location data available for table selection');
        alert('Please select a location first');
        return;
    }
    
    // Remove selected class from all table buttons
    const allTableButtons = document.querySelectorAll('.tableBtn');
    allTableButtons.forEach(btn => btn.classList.remove('selected'));
    
    // Add selected class to the clicked button
    buttonElement.classList.add('selected');
    
    const tableNumber = buttonElement.textContent;
    const isTakeaway = buttonElement.classList.contains('takeaway-btn');
    
    // Store selected table info
    window.selectedTableInfo = {
        tableNumber: tableNumber,
        isTakeaway: isTakeaway,
        location: selectedLocationData
    };
    
    // Set global order type variables for WhatsApp message
    currentOrderType = isTakeaway ? 'takeaway' : 'table';
    currentTableNumber = tableNumber;
    
    // Update the modal to show confirmation
    const tableNumElement = document.getElementById('myTableNum');
    if (tableNumElement) {
        if (isTakeaway) {
            tableNumElement.textContent = 'Ready to place your takeaway order?';
        } else {
            tableNumElement.textContent = `Table: ${tableNumber} at ${selectedLocationData.address}`;
        }
    }
    
    if (isTakeaway) {
        // For takeaway, update the summary display and go to order confirmation
        updateOrderSummary(selectedLocationData);
        // Show the summary for takeaway orders
        document.getElementById('orderSummaryDisplay').classList.remove('hide');
    } else {
        // For table orders, hide the summary
        document.getElementById('orderSummaryDisplay').classList.add('hide');
    }
    
    // Show the confirmation modal
    document.getElementById('confirmmodal').classList.add('show');
}

function confirmTable(state){
	if(myTable!=''){
		// if(	myTable.endsWith('2L')||myTable.endsWith('14R')){
		// 	number="";
		// }else if(	myTable.endsWith('1')||myTable.endsWith('18R')){
		// 	number="";
		// }else if(	myTable.endsWith('2')||myTable.endsWith('8L')){
		// 	number="";
		// }
		if (state=='askforserver'){
			askforserver();
		}else{
			confirm();
		}
		
	}
}

function askforserver(){
	message = 'https://wa.me/'+number+'?text='+encodeURIComponent('Powered by TTMenus\n'+name+'\n\nHello, Good Day\n'+'Server Requested at Table# '+myTable);
	confirmSendOrder();
}

// Function to find closest location (simplified for dropdown)
function findClosestLocation() {
	alert('Please use the location dropdown in the cart to select your preferred location.');
}

// Function to calculate distance (simplified for dropdown)
function calculateDistance(lat1, lon1, lat2, lon2) {
	// This function is kept for compatibility but not used in dropdown system
	return 0;
}

// Function to scroll to location (simplified for dropdown)
function scrollToLocation(locationElement) {
	// This function is kept for compatibility but not used in dropdown system
	console.log('üìç Location scrolling not needed with dropdown system');
}

// Function to manually set active location (simplified for dropdown)
function setActiveLocation(locationElement) {
	// This function is kept for compatibility but now uses dropdown selection
	const locationSelect = document.getElementById('locationSelect');
	if (locationSelect && locationSelect.value) {
		selectLocation(locationSelect.value);
	}
}

// Function to search locations based on user input
function searchLocations(searchTerm) {
	console.log('üîç Searching for:', searchTerm);
	
	const searchInput = document.getElementById('locationSearch');
	const locationItems = document.querySelectorAll('.locations .location-item');
	
	if (!searchTerm || searchTerm.trim() === '') {
		// Show all locations when search is empty
		locationItems.forEach(item => {
			item.style.display = 'flex';
			item.style.opacity = '1';
			item.style.transform = 'scale(1)';
		});
		
		// Remove any search highlighting
		document.querySelectorAll('.location-item .locbtn').forEach(btn => {
			btn.style.backgroundColor = '';
			btn.style.color = '';
			btn.style.fontWeight = '';
		});
		
		console.log('‚úÖ Showing all locations');
		return;
	}
	
	const searchLower = searchTerm.toLowerCase().trim();
	let foundCount = 0;
	
	locationItems.forEach(item => {
		const locationText = item.querySelector('.locbtn').textContent.toLowerCase();
		const isMatch = locationText.includes(searchLower);
		
		if (isMatch) {
			// Show and highlight matching locations
			item.style.display = 'flex';
			item.style.opacity = '1';
			item.style.transform = 'scale(1.02)';
			
			// Highlight the matching text
			const btn = item.querySelector('.locbtn');
			btn.style.backgroundColor = '#4CAF50';
			btn.style.color = 'white';
			btn.style.fontWeight = 'bold';
			
			foundCount++;
			console.log('‚úÖ Match found:', item.querySelector('.locbtn').textContent.trim());
		} else {
			// Hide non-matching locations
			item.style.display = 'none';
		}
	});
	
	console.log(`üîç Search complete: ${foundCount} location(s) found`);
	
	// Show search results count
	if (searchInput) {
		const currentPlaceholder = searchInput.placeholder;
		if (foundCount > 0) {
			searchInput.style.borderColor = '#4CAF50';
			searchInput.placeholder = `Found ${foundCount} location(s)`;
		} else {
			searchInput.style.borderColor = '#f44336';
			searchInput.placeholder = 'No locations found';
		}
		
		// Reset placeholder after 3 seconds
		setTimeout(() => {
			searchInput.placeholder = currentPlaceholder;
			searchInput.style.borderColor = '#ddd';
		}, 3000);
	}
}

// Function to clear search and show all locations
function clearLocationSearch() {
	const searchInput = document.getElementById('locationSearch');
	if (searchInput) {
		searchInput.value = '';
		searchLocations(''); // This will show all locations
	}
}

// Function to update the cart location display (simplified for dropdown)
function updateCartLocation(locationElement) {
	// This function is kept for compatibility but now uses dropdown data
	updateCartLocationDisplay();
}

// Function to update search placeholder (simplified for dropdown)
function updateSearchPlaceholder() {
	// This function is kept for compatibility but not used in dropdown system
	console.log('üîç Search placeholder not needed with dropdown system');
}

// Function to navigate locations (simplified for dropdown)
function scrollLocations(direction) {
	// This function is kept for compatibility but not used in dropdown system
	console.log('üîÑ Location scrolling not needed with dropdown system');
}

// Function to toggle delivery options visibility
function toggleDelivery(button) {
	const deliveryOptions = button.nextElementSibling;
	if (deliveryOptions && deliveryOptions.classList.contains('delivery-options')) {
		deliveryOptions.classList.toggle('hide');
		
		// Update button text to show current state
		const buttonText = button.querySelector('span');
		if (buttonText) {
			if (deliveryOptions.classList.contains('hide')) {
				buttonText.textContent = 'Delivery';
			} else {
				buttonText.textContent = 'Hide';
			}
		}
		
		console.log('üõµ Delivery options toggled for location');
	} else {
		console.log('‚ùå Delivery options container not found');
	}
}


document.addEventListener("DOMContentLoaded", function() {
  requestAnimationFrame(() => { // Ensures DOM is ready
    // Initialize cart display (shows empty state if needed)
    buildCartCards();
    
    loadCart();  // Load saved cart from localStorage
    updateCart(order.length);
    
    // Preload menu items JSON for faster item loading
    fetchMenuItems().then(() => {
      console.log('‚úÖ Menu items preloaded and ready');
    }).catch(err => {
      console.error('‚ùå Failed to preload menu items:', err);
    });
    
    // Initialize location dropdown and load saved location
    const locationSelect = document.getElementById('locationSelect');
    if (locationSelect) {
      console.log('üìç Location dropdown initialized');
      
      // Load saved location from localStorage
      const savedLocation = loadSelectedLocation();
      if (savedLocation) {
        // Set the dropdown to the saved location
        if (setLocationDropdown(savedLocation)) {
          // Update the WhatsApp number and trigger location selection
          number = savedLocation;
          selectLocation(savedLocation);
          console.log('‚úÖ Saved location restored:', savedLocation);
        }
      } else {
        // No saved location, use the first available location (already selected by default)
        const firstOption = locationSelect.options[1]; // Skip the "Select a location" option
        if (firstOption && firstOption.value) {
          number = firstOption.value;
          selectLocation(firstOption.value);
          console.log('üìç Using default location:', firstOption.value);
        }
      }
    }
    
    // Add manual trigger for testing
    window.testWhatsAppUpdate = function() {
      console.log('üîß Manual test triggered');
      console.log('üì± Current WhatsApp number:', number);
    };
    
    // Add debug function to show current state
    window.debugWhatsAppState = function() {
      console.log('üîç DEBUG: Current WhatsApp State');
      console.log('üì± Current number:', number);
      console.log('üìç Location dropdown system active');
    };
    
    // Add function to test location detection
    window.testLocationDetection = function() {
      console.log('üß™ TESTING: Location Detection');
      const locationSelect = document.getElementById('locationSelect');
      if (locationSelect) {
        console.log('üìç Location dropdown found');
        console.log('üìç Selected value:', locationSelect.value);
        console.log('üìç Total options:', locationSelect.options.length);
      } else {
        console.log('‚ùå Location dropdown not found');
      }
    };
    
    // Add function to test geolocation
    window.testGeolocation = function() {
      console.log('üß™ TESTING: Geolocation');
      console.log('navigator.geolocation exists:', !!navigator.geolocation);
      
      if (navigator.geolocation) {
        console.log('‚úÖ Geolocation is supported');
        console.log('Requesting permission...');
        
        navigator.geolocation.getCurrentPosition(
          function(position) {
            console.log('‚úÖ SUCCESS: Location permission granted!');
            console.log('Coordinates:', position.coords.latitude, position.coords.longitude);
            console.log('Accuracy:', position.coords.accuracy, 'meters');
          },
          function(error) {
            console.log('‚ùå ERROR: Location permission denied or error occurred');
            console.log('Error code:', error.code);
            console.log('Error message:', error.message);
          },
          {
            enableHighAccuracy: true,
            timeout: 10000,
            maximumAge: 60000
          }
        );
      } else {
        console.log('‚ùå Geolocation not supported');
      }
    };
    
    // Add function to test scrolling to specific locations
    window.testScrollToLocation = function(locationIndex = 0) {
      console.log('üß™ TESTING: Scroll to Location');
      const locationElements = document.querySelectorAll('.locations .location-item .locbtn');
      
      if (locationElements.length === 0) {
        console.log('‚ùå No location elements found');
        return;
      }
      
      const targetLocation = locationElements[locationIndex];
      if (!targetLocation) {
        console.log(`‚ùå Location at index ${locationIndex} not found`);
        console.log(`Available locations: 0 to ${locationElements.length - 1}`);
        return;
      }
      
      console.log(`üéØ Testing scroll to location ${locationIndex}:`, targetLocation.textContent.trim());
      console.log('üìç Current scroll position:', document.querySelector('.locations')?.scrollLeft || 'N/A');
      
      // Test the scroll function
      scrollToLocation(targetLocation);
    };
    
    // Add function to test all locations scrolling
    window.testAllLocationsScrolling = function() {
      console.log('üß™ TESTING: All Locations Scrolling');
      const locationElements = document.querySelectorAll('.locations .location-item .locbtn');
      
      if (locationElements.length === 0) {
        console.log('‚ùå No location elements found');
        return;
      }
      
      console.log(`üîç Found ${locationElements.length} locations`);
      
      // Test scrolling to each location with delays
      locationElements.forEach((location, index) => {
        setTimeout(() => {
          console.log(`\nüéØ Testing location ${index + 1}/${locationElements.length}:`, location.textContent.trim());
          scrollToLocation(location);
        }, index * 2000); // 2 second delay between each test
      });
    };
    
    // Add function to test location search
    window.testLocationSearch = function(searchTerm = 'Port') {
      console.log('üß™ TESTING: Location Search');
      console.log('Search term:', searchTerm);
      
      // Test the search function
      searchLocations(searchTerm);
      
      // Show current search state
      const searchInput = document.getElementById('locationSearch');
      if (searchInput) {
        console.log('üîç Search input value:', searchInput.value);
        console.log('üîç Search input placeholder:', searchInput.placeholder);
      }
      
      // Count visible locations
      const visibleLocations = document.querySelectorAll('.locations .location-item[style*="display: flex"]');
      const hiddenLocations = document.querySelectorAll('.locations .location-item[style*="display: none"]');
      
      console.log('üìç Visible locations:', visibleLocations.length);
      console.log('üö´ Hidden locations:', hiddenLocations.length);
      
      // Show visible location names
      visibleLocations.forEach((item, index) => {
        const text = item.querySelector('.locbtn').textContent.trim();
        console.log(`  ${index + 1}. ${text}`);
      });
    };
    
    // Add function to test cart location updates (simplified for dropdown)
    window.testCartLocation = function() {
      console.log('üß™ TESTING: Cart Location Updates');
      
      const locationSelect = document.getElementById('locationSelect');
      if (locationSelect) {
        console.log('‚úÖ Location dropdown found');
        console.log('üìç Current selection:', locationSelect.value);
        console.log('üìç Current text:', locationSelect.options[locationSelect.selectedIndex]?.text || 'None');
      } else {
        console.log('‚ùå Location dropdown not found');
      }
    };
    
    // Add function to test search placeholder updates (simplified for dropdown)
    window.testSearchPlaceholder = function() {
      console.log('üß™ TESTING: Search Placeholder');
      console.log('üîç Search placeholder not needed with dropdown system');
    };
    
    // Add function to test location navigation (simplified for dropdown)
    window.testLocationNavigation = function() {
      console.log('üß™ TESTING: Location Navigation');
      console.log('üìç Navigation not needed with dropdown system');
    };
    
    // Add function to test delivery options (simplified for dropdown)
    window.testDeliveryOptions = function() {
      console.log('üß™ TESTING: Delivery Options');
      console.log('üõµ Delivery options testing not implemented for dropdown system');
    };
    
    // Add function to test locations data loading (simplified for dropdown)
    window.testLocationsData = function() {
      console.log('üß™ TESTING: Locations Data Loading');
      
      const locationSelect = document.getElementById('locationSelect');
      if (locationSelect) {
        console.log('‚úÖ Location dropdown found');
        console.log('üìç Total options:', locationSelect.options.length);
        
        // Check each location's data
        for (let i = 0; i < locationSelect.options.length; i++) {
          const option = locationSelect.options[i];
          if (option.value) {
            console.log(`Location ${i}:`);
            console.log(`  Address: ${option.text}`);
            console.log(`  WhatsApp: ${option.value}`);
            console.log(`  Lat: ${option.getAttribute('data-lat') || 'NOT SET'}`);
            console.log(`  Lng: ${option.getAttribute('data-lng') || 'NOT SET'}`);
          }
        }
      } else {
        console.log('‚ùå Location dropdown not found');
      }
    };
    
    // WhatsApp ordering system loaded. Use testWhatsAppUpdate() to test manually.
  });
});

// Make functions globally available for table modal integration
window.setTableNumber = setTableNumber;
window.confirm = confirm;
window.advanceOrder = advanceOrder;
window.openTableModalWithLocation = openTableModalWithLocation;
window.getLocationDataFromElement = getLocationDataFromElement;
window.updateCartLocationDisplay = updateCartLocationDisplay;

// Add debugging and testing functions
window.testTableModalIntegration = function() {
	console.log('üß™ TESTING: Table Modal Integration');
	console.log('üìç Current location:', getVisibleLocation()?.textContent.trim() || 'None');
	console.log('üì± Current WhatsApp number:', number);
	console.log('ü™ë Current table:', myTable);
	console.log('üõí Current order mode:', currentMode);
	console.log('üì¶ Cart items:', order.length);
	console.log('üåê Global functions available:', {
		setTableNumber: typeof window.setTableNumber,
		confirm: typeof window.confirm,
		advanceOrder: typeof window.advanceOrder,
		openTableModal: typeof window.openTableModal
	});
	
	// Test location data extraction
	const currentLocation = getVisibleLocation();
	if (currentLocation) {
		const locationData = getLocationDataFromElement(currentLocation);
		console.log('üîç Extracted location data:', locationData);
	} else {
		console.log('‚ùå No visible location found');
	}
};

window.testLocationDataAttributes = function() {
	console.log('üß™ TESTING: Location Data Attributes');
	
	const locationElements = document.querySelectorAll('li.locations .locbtn');
	console.log(`Found ${locationElements.length} location elements`);
	
	locationElements.forEach((element, index) => {
		console.log(`\nüìç Location ${index + 1}: "${element.textContent.trim()}"`);
		console.log('  Data attributes:');
		console.log('    data-whatsapp:', element.dataset.whatsapp || 'NOT SET');
		console.log('    data-lat:', element.dataset.lat || 'NOT SET');
		console.log('    data-lng:', element.dataset.lng || 'NOT SET');
		console.log('    data-orderingtables:', element.dataset.orderingtables || 'NOT SET');
		
		// Test data extraction
		const locationData = getLocationDataFromElement(element);
		if (locationData) {
			console.log('  ‚úÖ Data extraction successful:', locationData);
		} else {
			console.log('  ‚ùå Data extraction failed');
		}
	});
};

window.testTableSelection = function() {
	console.log('üß™ TESTING: Table Selection Process');
	
	// Simulate the complete flow
	const currentLocation = getVisibleLocation();
	if (currentLocation) {
		console.log('üéØ Testing with location:', currentLocation.textContent.trim());
		
		// Test location data extraction
		const locationData = getLocationDataFromElement(currentLocation);
		if (locationData) {
			console.log('‚úÖ Location data extracted successfully');
			
			// Test opening table modal
			console.log('üöÄ Opening table modal...');
			openTableModalWithLocation(locationData);
		} else {
			console.log('‚ùå Failed to extract location data');
		}
	} else {
		console.log('‚ùå No location selected, cannot test table selection');
	}
};

// WhatsApp ordering system loaded with table modal integration
// Available global functions: setTableNumber, confirm, advanceOrder
// Testing functions: testTableModalIntegration, testTableSelection, testLocationDataAttributes

// var lastScrollTop = 0;
// document.addEventListener("scroll", function(){ // or window.addEventListener("scroll"....
//    var st = window.pageYOffset || document.documentElement.scrollTop; // Credits: "https://github.com/qeremy/so/blob/master/so.dom.js#L426"
//    var footerBtns = document.getElementById("footerBtns");
//    //var accessibility = document.getElementById("accessibility");
//    var cart = document.getElementById("cart");
//    if (st > lastScrollTop ) {
//       footerBtns.classList.add('bigfont');
//       footerBtns.classList.add('grad1');
//       footerBtns.classList.remove('smallfont');
//       footerBtns.classList.remove('grad2');
//    } else if (st < lastScrollTop && !cart.classList.contains('hide')) {
//       footerBtns.classList.add('smallfont');
//       footerBtns.classList.add('grad2');
//       footerBtns.classList.remove('bigfont');
//       footerBtns.classList.remove('grad1');
//    } // else was horizontal scroll
//    lastScrollTop = st <= 0 ? 0 : st; // For Mobile or negative scrolling
// }, false);


function toggleTTMS(){
    var ttms = document.getElementById("ttmenusModal");
    var footerBtns = document.getElementById("footerBtns");
    if(ttms.classList.contains('cart-hidden')){
      ttms.classList.remove('cart-hidden');
      footerBtns.classList.add('bigfont');
      footerBtns.classList.remove('smallfont');
      footerBtns.classList.add('grad1');
      footerBtns.classList.remove('grad2');
    }else{
      ttms.classList.add('cart-hidden');
      footerBtns.classList.add('grad2');
      footerBtns.classList.remove('grad1');
      footerBtns.classList.remove('bigfont');
      footerBtns.classList.add('smallfont');
      
    }
  }
  function closeTTMS(){
    var ttms = document.getElementById("ttmenusModal");
    var footerBtns = document.getElementById("footerBtns");
    ttms.classList.add('cart-hidden');
    footerBtns.classList.add('grad2');
    footerBtns.classList.remove('grad1');
    footerBtns.classList.remove('bigfont');
    footerBtns.classList.add('smallfont');
	}

// FOOTER SETTINGS/ACCESSIBILITY TOGGLE
function toggleFooterAccessibility(){
    var settings = document.getElementById("footerSettings");
    var footerBtns = document.getElementById("footerBtns");
    if(settings.classList.contains('hide')){
      settings.classList.remove('hide');
      footerBtns.classList.add('bigfont');
      footerBtns.classList.remove('smallfont');
      footerBtns.classList.add('grad1');
      footerBtns.classList.remove('grad2');
    }else{
      settings.classList.add('hide');
      footerBtns.classList.add('grad2');
      footerBtns.classList.remove('grad1');
      footerBtns.classList.remove('bigfont');
      footerBtns.classList.add('smallfont');
    }
  }

// ===== TABLE MODAL FUNCTIONS =====

// Global variable to store the selected location data
let selectedLocationData = null;

// Global variables to store order type information
let currentOrderType = 'takeaway'; // 'takeaway' or 'table'
let currentTableNumber = '';

// Function to populate table numbers based on selected location
function populateTableNumbers(locationData) {
    const tableButtonsContainer = document.getElementById('dynamicTableButtons');
    
    if (!locationData || !locationData.orderingtables) {
        // Fallback to default table numbers if no location data
        tableButtonsContainer.innerHTML = `
            <a class="tableBtn" href="#here" onclick="selectTable(this);">1</a>
            <a class="tableBtn" href="#here" onclick="selectTable(this);">2</a>
            <a class="tableBtn" href="#here" onclick="selectTable(this);">3</a>
            <a class="tableBtn" href="#here" onclick="selectTable(this);">4</a>
            <a class="tableBtn" href="#here" onclick="selectTable(this);">5</a>
            <a class="tableBtn" href="#here" onclick="selectTable(this);">6</a>
            <a class="tableBtn" href="#here" onclick="selectTable(this);">7</a>
            <a class="tableBtn" href="#here" onclick="selectTable(this);">8</a>
            <a class="tableBtn" href="#here" onclick="selectTable(this);">9</a>
            <a class="tableBtn" href="#here" onclick="selectTable(this);">10</a>
        `;
        return;
    }
    
    // Clear existing buttons
    tableButtonsContainer.innerHTML = '';
    
    // Process each ordering table option
    locationData.orderingtables.forEach((tableOption, index) => {
        if (tableOption === "Takeway Only") {
            // Add takeaway option
            const takeawayBtn = document.createElement('a');
            takeawayBtn.className = 'tableBtn takeaway-btn';
            takeawayBtn.href = '#here';
            takeawayBtn.onclick = function() { selectTable(this); };
            takeawayBtn.textContent = 'Takeaway';
            takeawayBtn.style.background = 'linear-gradient(#ff6b35, #f7931e)';
            tableButtonsContainer.appendChild(takeawayBtn);
        } else if (tableOption.startsWith('Tables')) {
            // Extract table numbers from "Tables1", "Tables2", etc.
            const tableNumber = tableOption.replace('Tables', '');
            const tableBtn = document.createElement('a');
            tableBtn.className = 'tableBtn';
            tableBtn.href = '#here';
            tableBtn.onclick = function() { selectTable(this); };
            tableBtn.textContent = tableNumber;
            tableButtonsContainer.appendChild(tableBtn);
        } else {
            // Handle other table options
            const tableBtn = document.createElement('a');
            tableBtn.className = 'tableBtn';
            tableBtn.href = '#here';
            tableBtn.onclick = function() { selectTable(this); };
            tableBtn.textContent = tableOption;
            tableButtonsContainer.appendChild(tableBtn);
        }
    });
}

// Function to open table modal with location data from WhatsApp ordering system
function openTableModal() {
    // Check if we have location data from the WhatsApp ordering system
    if (window.currentOrderLocation) {
        // Set the selected location data
        selectedLocationData = window.currentOrderLocation;
        
        // Update the location display
        updateSelectedLocationDisplay(window.currentOrderLocation);
        
        // Check if the location has ordering tables
        if (window.currentOrderLocation.orderingtables && window.currentOrderLocation.orderingtables.length > 0) {
            selectedLocationData = window.currentOrderLocation;
            populateTableNumbers(window.currentOrderLocation);
        } else {
            // Use fallback table numbers
            populateTableNumbers(null);
        }
        
        
    } else {
        alert('Please select a location first before placing your order.');
        return;
    }
    
    // Show the modal
    document.getElementById('tableNumberModal').classList.remove('hide');
    
    // Show table selection section immediately since we have location data
    document.getElementById('tableSelectionSection').classList.remove('hide');
}

// Function to update the selected location display
function updateSelectedLocationDisplay(locationData) {
    const locationDisplay = document.getElementById('selectedLocationDisplay');
    if (locationDisplay && locationData) {
        locationDisplay.innerHTML = `
            <div class="selected-location-info">
                <strong>üìç ${locationData.address}</strong>
                ${locationData.whatsapp ? `<br><small>üì± ${locationData.whatsapp}</small>` : ''}
                ${locationData.phone ? `<br><small>üìû ${locationData.phone}</small>` : ''}
            </div>
        `;
    }
}

// Function to update the order summary display for takeaway orders
function updateOrderSummary(locationData) {
    const summaryLocationInfo = document.getElementById('summaryLocationInfo');
    if (summaryLocationInfo && locationData) {
        summaryLocationInfo.innerHTML = `
            <div>${locationData.address}</div>
            ${locationData.whatsapp ? `<small>üì± ${locationData.whatsapp}</small>` : ''}
            ${locationData.phone ? `<small>üìû ${locationData.phone}</small>` : ''}
        `;
    }
}

// ===== TESTING FUNCTIONS =====

// Simple test function to manually test the table modal
window.testTableModalManually = function() {
    console.log('üß™ MANUAL TEST: Opening table modal with test data');
    
    const testLocationData = {
        address: 'Test Location - 123 Test Street',
        whatsapp: '+1234567890',
        lat: '40.7128',
        lng: '-74.0060',
        orderingtables: ['Takeway Only', 'Tables1', 'Tables2', 'Tables3']
    };
    
    console.log('üìç Test location data:', testLocationData);
    
    // Call the function directly
    openTableModalWithLocation(testLocationData);
};

// Simple function to just show the modal without data
window.showTableModal = function() {
    document.getElementById('tableNumberModal').classList.remove('hide');
    console.log('‚úÖ Table modal should now be visible');
};

// Test table modal functions
window.testTableModal = function() {
    console.log('üß™ TESTING: Table Modal Functions');
    console.log('üìç Selected location data:', selectedLocationData);
    console.log('üåê Current order location:', window.currentOrderLocation);
    console.log('üîß Functions available:', {
        populateTableNumbers: typeof populateTableNumbers,
        openTableModal: typeof openTableModal,
        openTableModalWithLocation: typeof openTableModalWithLocation,
        selectTable: typeof selectTable,
        closeTableModal: typeof closeTableModal,
        confirmTable: typeof confirmTable,
        updateSelectedLocationDisplay: typeof updateSelectedLocationDisplay
    });
    
    // Test location data
    if (window.currentOrderLocation) {
        console.log('üîç Testing location data...');
        console.log('‚úÖ Location data found:', window.currentOrderLocation);
        
        if (window.currentOrderLocation.orderingtables) {
            console.log('üìã Ordering tables available:', window.currentOrderLocation.orderingtables);
        }
    }
};

// Test table population
window.testTablePopulation = function() {
    console.log('üß™ TESTING: Table Population');
    
    if (selectedLocationData) {
        console.log('üìç Using selected location:', selectedLocationData);
        populateTableNumbers(selectedLocationData);
    } else if (window.currentOrderLocation) {
        console.log('üìç Using current order location:', window.currentOrderLocation);
        if (window.currentOrderLocation.orderingtables) {
            populateTableNumbers(window.currentOrderLocation);
        }
    } else {
        console.log('‚ùå No location data available for testing');
    }
};

    // Add function to test horizontal scrolling (simplified for dropdown)
    window.testHorizontalScrolling = function() {
      console.log('üß™ TESTING: Horizontal Scrolling (not needed with dropdown)');
      console.log('üìç Dropdown system does not require horizontal scrolling');
    };
    
    // Add function to manually scroll (simplified for dropdown)
    window.testHorizontalScroll = function(direction = 'right') {
      console.log(`üß™ TESTING: Manual horizontal scroll (not needed with dropdown)`);
      console.log('üìç Dropdown system does not require scrolling');
    };
    
    // Add function to manually select a location (simplified for dropdown)
    window.selectLocationByIndex = function(index = 0) {
      console.log(`üß™ TESTING: Manually selecting location at index ${index}`);
      
      const locationSelect = document.getElementById('locationSelect');
      if (locationSelect && locationSelect.options.length > index) {
        locationSelect.selectedIndex = index;
        locationSelect.dispatchEvent(new Event('change'));
        console.log('‚úÖ Location selection completed via dropdown');
      } else {
        console.log('‚ùå Location dropdown not found or invalid index');
      }
    };
    
    // Add function to show all available locations (simplified for dropdown)
    window.showAllLocations = function() {
      console.log('üß™ TESTING: Show all available locations');
      
      const locationSelect = document.getElementById('locationSelect');
      if (locationSelect) {
        console.log(`Found ${locationSelect.options.length} locations in dropdown:`);
        
        for (let i = 0; i < locationSelect.options.length; i++) {
          const option = locationSelect.options[i];
          if (option.value) {
            console.log(`${i}: "${option.text}" - WhatsApp: ${option.value}`);
          }
        }
        
        console.log('\nUse selectLocationByIndex(index) to select a specific location');
      } else {
        console.log('‚ùå Location dropdown not found');
      }
    };

    // Function to close table modal
    function closeTableModal() {
        document.getElementById('tableNumberModal').classList.add('hide');
        document.getElementById('confirmmodal').classList.remove('show');
        document.querySelector('.input').classList.remove('hide');
        
        // Hide the table selection section
        const tableSelectionSection = document.getElementById('tableSelectionSection');
        if (tableSelectionSection) {
            tableSelectionSection.classList.remove('show');
        }
        
        // Remove selected class from all table buttons
        const allTableButtons = document.querySelectorAll('.tableBtn');
        allTableButtons.forEach(btn => btn.classList.remove('selected'));
        
        // Hide the order summary display
        const orderSummaryDisplay = document.getElementById('orderSummaryDisplay');
        if (orderSummaryDisplay) {
            orderSummaryDisplay.classList.add('hide');
        }
        
        // Clear the order summary display
        const summaryLocationInfo = document.getElementById('summaryLocationInfo');
        if (summaryLocationInfo) {
            summaryLocationInfo.innerHTML = '';
        }
        
        // Reset selected table info
        window.selectedTableInfo = null;
        selectedLocationData = null;
        
        // Clear the current order location
        window.currentOrderLocation = null;
        
        // NOTE: Do NOT clear currentOrderType and currentTableNumber here
        // They are needed for the WhatsApp message construction
    }

    // Function to confirm table selection
    function confirmTable(action) {
        if (!window.selectedTableInfo) {
            console.error('‚ùå No table selected');
            alert('No table selected. Please try again.');
            return;
        }
        
        const { tableNumber, isTakeaway, location } = window.selectedTableInfo;
        
        // Both table and takeaway orders go directly to WhatsApp order
        console.log(`üìã Placing order for ${isTakeaway ? 'takeaway' : 'table'} ${tableNumber} at location: ${location.address}`);
        
        // Set the table number in the WhatsApp ordering system
        if (typeof window.setTableNumber === 'function') {
            window.setTableNumber(tableNumber);
        } else {
            // Fallback: try to set the table number directly
            if (window.myTable !== undefined) {
                window.myTable = tableNumber;
            }
        }
        
        // Close the modal and proceed with order
        closeTableModal();
        
        // Trigger the order confirmation in the WhatsApp ordering system
        if (typeof window.confirm === 'function') {
            window.confirm();
        } else {
            console.error('‚ùå Confirm function not found');
        }
    }

    // ===== TESTING FUNCTIONS =====

    // Add function to test order type variables
    window.testOrderTypeVariables = function() {
    	console.log('üß™ TESTING: Order Type Variables');
    	console.log('üìç Current order type:', currentOrderType);
    	console.log('ü™ë Current table number:', currentTableNumber);
    	console.log('üì± Current WhatsApp number:', number);
    	console.log('üõí Current order mode:', currentMode);
    	console.log('üåê Global functions available:', {
    		setTableNumber: typeof window.setTableNumber,
    		confirm: typeof window.confirm,
    		advanceOrder: typeof window.advanceOrder
    	});
    	
    	// Test the message construction
    	console.log('üß™ Testing message construction...');
    	const testMessageStart = 'Powered by TTMenus\n'+name+'\nHello, Good Day\nI would like to order the following\n\nORDER\n';
    	const testMessageBody = '#1 | Test Item | Qty1 $10\n';
    	const testMessageEnd = '\nThank You!\nLooking forward to confirming this order';
    	
    	let testLabel = '';
    	if (currentOrderType === 'takeaway') {
    		testLabel = 'Takeaway';
    	} else if (currentOrderType === 'table' && currentTableNumber && currentTableNumber.trim() !== '') {
    		testLabel = `Table #${currentTableNumber}`;
    	} else {
    		testLabel = 'Takeaway'; // Default fallback
    	}
    	
    	const testMessage = testMessageStart + testLabel + '\n' + testMessageBody + testMessageEnd;
    	console.log('üìù Test message preview:');
    	console.log(testMessage);
    	console.log('‚úÖ Label used:', testLabel);
    };

    // WhatsApp ordering system loaded with table modal integration

    // Simple location selection function for dropdown
    function selectLocation(whatsappNumber) {
        if (whatsappNumber && whatsappNumber.trim() !== '') {
            const oldNumber = number;
            number = whatsappNumber;
            console.log('üìç Location selected - WhatsApp number changed from', oldNumber, 'to:', number);
            
            // Update cart location display
            updateCartLocationDisplay();
        } else {
            console.log('üìç No location selected');
            number = '{{ site.Params.orderingsystem.whatsapp }}'; // Reset to fallback
        }
    }

    // Function to update cart location display
    function updateCartLocationDisplay() {
        const locationSelect = document.getElementById('locationSelect');
        if (locationSelect && locationSelect.value) {
            const selectedOption = locationSelect.options[locationSelect.selectedIndex];
            const address = selectedOption.getAttribute('data-address');
            if (address) {
                console.log('üõí Cart location updated to:', address);
            }
        }
    }

    // Function to get current location data for table modal
    function getCurrentLocationData() {
        const locationSelect = document.getElementById('locationSelect');
        if (locationSelect && locationSelect.value) {
            const selectedOption = locationSelect.options[locationSelect.selectedIndex];
            const address = selectedOption.getAttribute('data-address');
            const whatsapp = selectedOption.value;
            const lat = selectedOption.getAttribute('data-lat');
            const lng = selectedOption.getAttribute('data-lng');
            const orderingTables = selectedOption.getAttribute('data-orderingtables');
            
            if (address && whatsapp) {
                let parsedOrderingTables = [];
                if (orderingTables && orderingTables.trim() !== '') {
                    parsedOrderingTables = orderingTables.split(',').map(table => table.trim());
                }
                
                return {
                    address: address,
                    whatsapp: whatsapp,
                    lat: lat,
                    lng: lng,
                    orderingtables: parsedOrderingTables
                };
            }
        }
        return null;
    }

    // Function to display taxonomy tags in the order modal
    function displayTaxonomyTags(options) {
        const tagsContainer = document.getElementById("itemtaxonomytags");
        
        if (!tagsContainer) {
            console.log("‚ùå Tags container not found");
            return;
        }
        
        // Helper function to slugify tag for URL
        function slugify(text) {
            return text.toLowerCase()
                .replace(/[^\w\s-]/g, '')
                .replace(/\s+/g, '-')
                .replace(/-+/g, '-')
                .trim();
        }
        
        // Define all taxonomy types with their display names and URL paths
        const taxonomies = [
            { key: 'tags', label: 'Tags', urlPath: '/tags/' },
            { key: 'ingredients', label: 'Ingredients', urlPath: '/ingredients/' },
            { key: 'cookingmethods', label: 'Cooking Methods', urlPath: '/cookingmethods/' },
            { key: 'types', label: 'Cuisine Types', urlPath: '/types/' },
            { key: 'events', label: 'Events', urlPath: '/events/' }
        ];
        
        let allTagsHtml = '';
        let hasAnyTags = false;
        
        // Loop through each taxonomy type
        taxonomies.forEach(taxonomy => {
            const items = options[taxonomy.key];
            
            if (items && Array.isArray(items) && items.length > 0) {
                hasAnyTags = true;
                
                // Create section for this taxonomy
                allTagsHtml += `<div class="taxonomy-section" data-taxonomy="${taxonomy.key}">`;
                allTagsHtml += `<span class="taxonomy-label">${taxonomy.label}:</span> `;
                
                // Add each item as a clickable link
                items.forEach((item, index) => {
                    const slug = slugify(item);
                    const url = `${taxonomy.urlPath}${slug}/`;
                    allTagsHtml += `<a href="${url}" class="tag tag-${taxonomy.key}" title="View all items with ${item}">${item}</a>`;
                    if (index < items.length - 1) {
                        allTagsHtml += ' ';
                    }
                });
                
                allTagsHtml += '</div>';
            }
        });
        
        if (hasAnyTags) {
            tagsContainer.innerHTML = `<div class="tags-container">${allTagsHtml}</div>`;
            tagsContainer.style.display = 'block';
            console.log("‚úÖ Taxonomies displayed:", {
                tags: options.tags?.length || 0,
                ingredients: options.ingredients?.length || 0,
                cookingmethods: options.cookingmethods?.length || 0,
                types: options.types?.length || 0,
                events: options.events?.length || 0
            });
        } else {
            // Hide tags container if no tags
            tagsContainer.innerHTML = '';
            tagsContainer.style.display = 'none';
            console.log("‚ÑπÔ∏è No taxonomies to display");
        }
    }
</script>